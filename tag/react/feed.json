{
    "version": "https://jsonfeed.org/version/1",
    "title": "李金城傻逼 • All posts by \"react\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/09/24/01.react%E5%85%A5%E9%97%A8/",
            "url": "http://example.com/2023/09/24/01.react%E5%85%A5%E9%97%A8/",
            "title": "React-入门",
            "date_published": "2023-09-24T10:57:52.000Z",
            "content_html": "<h1 id=\"01-【React-入门】\"><a href=\"#01-【React-入门】\" class=\"headerlink\" title=\"01 【React 入门】\"></a>01 【React 入门】</h1><h2 id=\"1-React-简介\"><a href=\"#1-React-简介\" class=\"headerlink\" title=\"1.React 简介\"></a>1.React 简介</h2><p><strong>react 是什么？</strong></p>\n<p><strong>React</strong> 是一个用于构建用户界面的 JavaScript 库。</p>\n<ul>\n<li>是一个将数据渲染为 HTML 视图的开源 JS 库</li>\n<li>它遵循基于组件的方法，有助于构建可重用的 UI 组件</li>\n<li>它用于开发复杂的交互式的 web 和移动 UI</li>\n</ul>\n<blockquote>\n<p>React 有什么特点？</p>\n</blockquote>\n<ol>\n<li>使用虚拟 DOM 而不是真正的 DOM</li>\n<li>它可以用服务器渲染</li>\n<li>它遵循单向数据流或数据绑定</li>\n<li>高效</li>\n<li>声明式编码，组件化编码</li>\n</ol>\n<blockquote>\n<p>React 的一些主要优点？</p>\n</blockquote>\n<ol>\n<li>它提高了应用的性能</li>\n<li>可以方便在客户端和服务器端使用</li>\n<li>由于使用 JSX，代码的可读性更好</li>\n<li>使用 React，编写 UI 测试用例变得非常容易</li>\n</ol>\n<p><strong>为什么学？</strong></p>\n<p>1.原生 JS 操作 DOM 繁琐，效率低</p>\n<p>2.使用 JS 直接操作 DOM,浏览器会进行大量的重绘重排</p>\n<p>3.原生 JS 没有组件化编码方案，代码复用低</p>\n<blockquote>\n<p>在学习之前最好看一下关于 npm 的知识：下面是我在网上看见的一个写的还不错的 npm 的文章</p>\n<p><a href=\"https://blog.csdn.net/qq_25502269/article/details/79346545\">npm</a></p>\n</blockquote>\n<h2 id=\"2-React-基础案例\"><a href=\"#2-React-基础案例\" class=\"headerlink\" title=\"2.React 基础案例\"></a>2.React 基础案例</h2><p>首先需要引入几个 react 包</p>\n<ul>\n<li>React 核心库、操作 DOM 的 react 扩展库、将 jsx 转为 js 的 babel 库</li>\n</ul>\n<p>【先引入 react.development.js，后引入 react-dom.development.js】</p>\n<blockquote>\n<p><code>react.development.js</code></p>\n<ul>\n<li>react 是 react 核心库，只要使用 react 就必须要引入</li>\n<li>下载地址：<a href=\"https://unpkg.com/react@18.0.0/umd/react.development.js\">https://unpkg.com/react@18.0.0/umd/react.development.js</a></li>\n</ul>\n<p><code>react-dom.development.js</code></p>\n<ul>\n<li>react-dom 是 react 的 dom 包，使用 react 开发 web 应用时必须引入</li>\n<li>下载地址：<a href=\"https://unpkg.com/react-dom@18.0.0/umd/react-dom.development.js\">https://unpkg.com/react-dom@18.0.0/umd/react-dom.development.js</a></li>\n</ul>\n<p><code>babel.min.js </code></p>\n<ul>\n<li><p>由于 JSX 最终需要转换为 JS 代码执行，所以浏览器并不能正常识别 JSX，所以当我们在浏览器中直接使用 JSX 时，还必须引入 babel 来完成对代码的编译。</p>\n</li>\n<li><p>babel 下载地址：<a href=\"https://unpkg.com/babel-standalone@6/babel.min.js\">https://unpkg.com/babel-standalone@6/babel.min.js</a></p>\n</li>\n</ul>\n</blockquote>\n<p><img src=\"https://i0.hdslb.com/bfs/album/514c5df0f5f8e7242ca17e1c939b4822b716315f.png\" alt=\"image-20221022171647360\"></p>\n<pre><code>react.development.js\nreact-dom.development.js\nbabel.min.js\n</code></pre>\n<p>2.创建一个容器</p>\n<p>3.创建虚拟 DOM，渲染到容器中</p>\n<pre><code class=\"js\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;title&gt;hello_react&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 准备好一个“容器” --&gt;\n    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;\n\n    &lt;!-- 引入react核心库 --&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;\n    &lt;!-- 引入react-dom，用于支持react操作DOM --&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;\n    &lt;!-- 引入babel，用于将jsx转为js --&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;\n\n    &lt;script type=&quot;text/babel&quot;&gt;\n      /* 此处一定要写babel */\n      //1.创建虚拟DOM\n      const VDOM = &lt;h1&gt;Hello&lt;/h1&gt; /* 此处一定不要写引号，因为不是字符串 */\n      //2.渲染虚拟DOM到页面\n    const root = ReactDOM.createRoot(document.querySelector(&#39;#test&#39;));\n      root.render(VDOM);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>后面很多地方没有用<code>createRoot</code>这种方式是因为一开始学的课程是 2020 年的，这是现在新的创建方式。</p>\n<p>这里我就只把第一个案例改成新方式了</p>\n</blockquote>\n<p>这样，就会在页面中的这个 div 容器上添加这个 h1.</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/7c5713f248cc28bcb531d2eda325e56789df4286.png\" alt=\"image-20221022171539523\"></p>\n<blockquote>\n<ul>\n<li>React.createElement()<ul>\n<li><code>React.createElement(type, [props], [...children])</code></li>\n<li>用来创建 React 元素</li>\n<li>React 元素无法修改</li>\n</ul>\n</li>\n<li>ReactDOM.createRoot()<ul>\n<li><code>createRoot(container[, options])</code></li>\n<li>用来创建 React 的根容器，容器用来放置 React 元素</li>\n</ul>\n</li>\n<li>ReactDOM.render()<ul>\n<li><code>root.render(element)</code></li>\n<li>用来将 React 元素渲染到根元素中</li>\n<li>根元素中所有的内容都会被删除，被 React 元素所替换</li>\n<li>当重复调用 render()时，React 会将两次的渲染结果进行比较，</li>\n<li>它会确保只修改那些发生变化的元素，对 DOM 做最少的修改</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"3-jsx-语法\"><a href=\"#3-jsx-语法\" class=\"headerlink\" title=\"3.jsx 语法\"></a>3.jsx 语法</h2><p>JSX 是 JavaScript 的语法扩展，JSX 使得我们可以以类似于 HTML 的形式去使用 JS。JSX 便是 React 中声明式编程的体现方式。声明式编程，简单理解就是以结果为导向的编程。使用 JSX 将我们所期望的网页结构编写出来，然后 React 再根据 JSX 自动生成 JS 代码。所以我们所编写的 JSX 代码，最终都会转换为以调用<code>React.createElement()</code>创建元素的代码。</p>\n<ol>\n<li>定义虚拟 DOM，JSX 不是字符串，不要加引号</li>\n<li>标签中混入 JS 表达式的时候使用<code>&#123;&#125;</code></li>\n</ol>\n<pre><code class=\"js\">id = &#123;myId.toUpperCase()&#125;\n</code></pre>\n<ol start=\"3\">\n<li><p>样式的类名指定不能使用 class，使用<code>className</code></p>\n</li>\n<li><p>内敛样式要使用<code>&#123;&#123;&#125;&#125;</code>包裹</p>\n</li>\n</ol>\n<pre><code class=\"js\">style=&#123;&#123;color:'skyblue',fontSize:'24px'&#125;&#125;\n</code></pre>\n<ol start=\"5\">\n<li><p>不能有多个根标签，只能有一个根标签</p>\n</li>\n<li><p>JSX 的标签必须正确结束（自结束标签必须写&#x2F;）</p>\n</li>\n<li><p>JSX 中 html 标签应该小写，React 组件应该大写开头。如果小写字母开头，就将标签转化为 html 同名元素，如果 html 中无该标签对应的元素，就报错；如果是大写字母开头，react 就去渲染对应的组件，如果没有就报错</p>\n</li>\n<li><p>如果表达式是空值、布尔值、undefined，将不会显示</p>\n</li>\n</ol>\n<blockquote>\n<p>关于 JS 表达式和 JS 语句：</p>\n<ul>\n<li><p>JS 表达式：返回一个值，可以放在任何一个需要值的地方 a a+b demo(a) arr.map() function text(){}</p>\n</li>\n<li><p>JS 语句：if(){} for(){} while(){} swith(){} 不会返回一个值</p>\n</li>\n</ul>\n</blockquote>\n<p><strong>其它</strong></p>\n<ol>\n<li>注释</li>\n</ol>\n<p>写在花括号里</p>\n<pre><code class=\"js\">ReactDOM.render(\n    &lt;div&gt;\n        &lt;h1&gt;小丞&lt;/h1&gt;\n        &#123;/*注释...*/&#125;\n    &lt;/div&gt;,\n    document.getElementById(&quot;example&quot;)\n);\n</code></pre>\n<ol start=\"2\">\n<li><code>class</code>需要使用<code>className</code>代替</li>\n<li><code>style</code>中必须使用对象设置<code> style=&#123;&#123;background:'red'&#125;&#125;</code></li>\n</ol>\n<pre><code class=\"js\">&lt;style&gt;\n    .title&#123;\n        background-color: orange;\n        width: 200px;\n    &#125;\n&lt;/style&gt;\n\n&lt;!-- 准备好一个“容器” --&gt;\n&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;\n\n&lt;script type=&quot;text/babel&quot; &gt;\n    const myId = &#39;aTgUiGu&#39;\n    const myData = &#39;HeLlo,rEaCt&#39;\n\n    //1.创建虚拟DOM\n    const VDOM = (\n        &lt;div&gt;\n            &lt;h2 className=&quot;title&quot; id=&#123;myId.toLowerCase()&#125;&gt;\n                &lt;span style=&#123;&#123;color:'white',fontSize:'29px'&#125;&#125;&gt;&#123;myData.toLowerCase()&#125;&lt;/span&gt;\n            &lt;/h2&gt;\n            &lt;h2 className=&quot;title&quot; id=&#123;myId.toLowerCase()&#125;&gt;\n                &lt;span style=&#123;&#123;color:'white',fontSize:'29px'&#125;&#125;&gt;&#123;myData.toUpperCase()&#125;&lt;/span&gt;\n            &lt;/h2&gt;\n            &lt;input type=&quot;text&quot;/&gt;\n        &lt;/div&gt;\n    )\n    //2.渲染虚拟DOM到页面\n    ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))\n&lt;/script&gt;\n</code></pre>\n<p><img src=\"https://i0.hdslb.com/bfs/album/9d4bafde75cb82f79b17a91491c46eb8576b784a.png\" alt=\"image-20221022204158589\"></p>\n<ol start=\"4\">\n<li>数组</li>\n</ol>\n<p>JSX 允许在模板中插入数组，数组自动展开全部成员</p>\n<blockquote>\n<p>{} 只能用来放 js 表达式，而不能放语句（if for）<br>在语句中是可以去操作 JSX</p>\n</blockquote>\n<pre><code class=\"js\">var arr = [&lt;h1&gt;小丞&lt;/h1&gt;, &lt;h2&gt;同学&lt;/h2&gt;];\nReactDOM.render(&lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById(&quot;example&quot;));\n</code></pre>\n<p><strong>tip: JSX 小练习</strong></p>\n<p>根据动态数据生成 <code>li</code></p>\n<pre><code class=\"js\">const data = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];\nconst VDOM = (\n    &lt;div&gt;\n        &lt;ul&gt;\n            &#123;data.map((item, index) =&gt; &#123;\n                return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;;\n            &#125;)&#125;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n);\nReactDOM.render(VDOM, document.querySelector(&quot;.test&quot;));\n</code></pre>\n<img src=\"https://i0.hdslb.com/bfs/album/09241923178d7fdca14d087e6f1a9627dc3b7081.png\" alt=\"image-20221022204645014\">\n\n<h2 id=\"4-两种创建虚拟-DOM-的方式\"><a href=\"#4-两种创建虚拟-DOM-的方式\" class=\"headerlink\" title=\"4.两种创建虚拟 DOM 的方式\"></a>4.两种创建虚拟 DOM 的方式</h2><p><strong>使用 JSX 创建虚拟 DOM</strong></p>\n<pre><code class=\"js\">//1.创建虚拟DOM\nconst VDOM = (\n    /* 此处一定不要写引号，因为不是字符串 */\n    &lt;h1 id=&quot;title&quot;&gt;\n        &lt;span&gt;Hello,React&lt;/span&gt;\n    &lt;/h1&gt;\n);\n//2.渲染虚拟DOM到页面\nReactDOM.render(VDOM, document.querySelector(&quot;.test&quot;));\n</code></pre>\n<p>这个在上面的案例中已经演示过了 ，下面看看另外一种创建虚拟 DOM 的方式</p>\n<p><strong>2.使用 JS 创建虚拟 DOM</strong></p>\n<pre><code class=\"js\">/*\n * React.createElement()\n *   - 用来创建一个React元素\n *   - 参数：\n *        1.元素的名称（html标签必须小写）\n *        2.标签中的属性\n *           - class属性需要使用className来设置\n *           - 在设置事件时，属性名需要修改为驼峰命名法\n *       3.元素的内容（子元素）\n *   - 注意点：\n *       React元素最终会通过虚拟DOM转换为真实的DOM元素\n *       React元素一旦创建就无法修改，只能通过新创建的元素进行替换\n * */\n</code></pre>\n<pre><code class=\"js\">//1.创建虚拟DOM,创建嵌套格式的dom\nconst VDOM = React.createElement(&quot;h1&quot;, &#123; id: &quot;title&quot; &#125;, React.createElement(&quot;span&quot;, &#123;&#125;, &quot;hello,React&quot;));\n//2.渲染虚拟DOM到页面\nReactDOM.render(VDOM, document.querySelector(&quot;.test&quot;));\n</code></pre>\n<p>使用 JS 和 JSX 都可以创建虚拟 DOM，但是可以看出 JS 创建虚拟 DOM 比较繁琐，尤其是标签如果很多的情况下，所以还是比较推荐使用 JSX 来创建。</p>\n<h2 id=\"5-两种-DOM-的区别\"><a href=\"#5-两种-DOM-的区别\" class=\"headerlink\" title=\"5.两种 DOM 的区别\"></a>5.两种 DOM 的区别</h2><pre><code class=\"js\">    &lt;!-- 准备好一个“容器” --&gt;\n    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;\n\n    &lt;script type=&quot;text/babel&quot;&gt;\n      /* 此处一定要写babel */\n      //1.创建虚拟DOM\n      const VDOM = &lt;h1&gt;Hello,React&lt;/h1&gt; /* 此处一定不要写引号，因为不是字符串 */\n      //2.渲染虚拟DOM到页面\n      ReactDOM.render(VDOM, document.getElementById(&#39;test&#39;))\n      const TDOM = document.querySelector(&#39;#test&#39;)\n      console.log(&#39;虚拟DOM&#39;, VDOM)\n      console.dir(&#39;真实DOM&#39;)\n      console.dir(TDOM)\n      //   debugger\n      console.log(typeof VDOM)\n      console.log(VDOM instanceof Object)\n</code></pre>\n<p><img src=\"https://i0.hdslb.com/bfs/album/3c9c35333c0883a1057bd4c82be8bfbf9b69f04b.png\" alt=\"image-20221022194600803\"></p>\n<p><strong>关于虚拟 DOM：</strong></p>\n<p>​ 1. 本质是 Object 类型的对象（一般对象）</p>\n<p>​ 2. 虚拟 DOM 比较“轻”，真实 DOM 比较“重”，因为虚拟 DOM 是 React 内部在用，无需真实 DOM 上那么多的属性。</p>\n<p>​ 3. 虚拟 DOM 最终会被 React 转化为真实 DOM，呈现在页面上。</p>\n",
            "tags": [
                "React"
            ]
        },
        {
            "id": "http://example.com/2023/09/24/04.react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
            "url": "http://example.com/2023/09/24/04.react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
            "title": "React-生命周期",
            "date_published": "2023-09-24T10:57:52.000Z",
            "content_html": "<h1 id=\"04-【生命周期】\"><a href=\"#04-【生命周期】\" class=\"headerlink\" title=\"04 【生命周期】\"></a>04 【生命周期】</h1><h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><p>组件从创建到死亡，会经过一些特定的阶段</p>\n<p>React 组件中包含一系列钩子函数{生命周期回调函数}，会在特定的时刻调用</p>\n<p>我们在定义组件的时候，会在特定的声明周期回调函数中，做特定的工作</p>\n<p>在 React 中为我们提供了一些生命周期钩子函数，让我们能在 React 执行的重要阶段，在钩子函数中做一些事情。那么在 React 的生命周期中，有哪些钩子函数呢，我们来总结一下</p>\n<p><strong>react 生命周期(旧)</strong></p>\n<pre><code class=\"js\">1. 初始化阶段: 由ReactDOM.render()触发---初次渲染\n                    1.\tconstructor()\n                    2.\tcomponentWillMount()\n                    3.\trender()\n                    4.\tcomponentDidMount() =====&gt; 常用\n                        一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息\n2. 更新阶段: 由组件内部this.setSate()或父组件render触发\n                    1.\tshouldComponentUpdate()\n                    2.\tcomponentWillUpdate()\n                    3.\trender() =====&gt; 必须使用的一个\n                    4.\tcomponentDidUpdate()\n3. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发\n                    1.\tcomponentWillUnmount()  =====&gt; 常用\n                        一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息\n</code></pre>\n<p><img src=\"https://i0.hdslb.com/bfs/album/eca620dfbbcdc3325be4a1f167f9a4ca2a0dfb7a.png\" alt=\"react生命周期(旧)\"></p>\n<p>在最新的 react 版本中，有些生命周期钩子被抛弃了，具体函数如下：</p>\n<ul>\n<li><code>componentWillMount</code></li>\n<li><code>componentWillReceiveProps</code></li>\n<li><code>componentWillUpdate</code></li>\n</ul>\n<p>这些生命周期方法经常被误解和滥用；此外，我们预计，在异步渲染中，它们潜在的误用问题可能更大。我们将在即将发布的版本中为这些生命周期添加 “UNSAFE_” 前缀。（这里的 “unsafe” 不是指安全性，而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug，尤其是在启用异步渲染之后。）</p>\n<p>由此可见，新版本中并不推荐持有这三个函数，取而代之的是带有 UNSAFE* 前缀的三个函数，比如: UNSAFE* componentWillMount。即便如此，其实 React 官方还是不推荐大家去使用，在以后版本中有可能会去除这几个函数。</p>\n<p><strong>react 生命周期(新)</strong></p>\n<pre><code class=\"js\">1. 初始化阶段: 由ReactDOM.render()触发---初次渲染\n                1.\tconstructor()\n                2.\tgetDerivedStateFromProps\n                3.\trender()\n                4.\tcomponentDidMount() =====&gt; 常用\n                    一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息\n2. 更新阶段: 由组件内部this.setSate()或父组件重新render触发\n                1.\tgetDerivedStateFromProps\n                2.\tshouldComponentUpdate()\n                3.\trender()\n                4.\tgetSnapshotBeforeUpdate\n                5.\tcomponentDidUpdate()\n3. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发\n                1.\tcomponentWillUnmount()  =====&gt; 常用\n                    一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息\n</code></pre>\n<p><img src=\"https://i0.hdslb.com/bfs/album/1ad3acfd13159cfdc364a487dfc4335f7a9a1a06.png\" alt=\"image-20221023222949399\"></p>\n<h2 id=\"2-初始化阶段\"><a href=\"#2-初始化阶段\" class=\"headerlink\" title=\"2.初始化阶段\"></a>2.初始化阶段</h2><p><strong>在组件实例被创建并插入到 dom 中时，生命周期调用顺序如下</strong></p>\n<p><strong>旧生命周期：</strong></p>\n<ol>\n<li>constructor（props）</li>\n<li>componentWillMount（）————-可以用但是不建议使用</li>\n<li>render（）</li>\n<li>componentDidMount（）</li>\n</ol>\n<p><strong>新生命周期：</strong></p>\n<ol>\n<li>constructor（props）</li>\n<li><code>static getDerivedStateFromProps（props，state）</code>–替代了<code>componentWillReceiveProps</code></li>\n<li>render（）</li>\n<li>componentDidMount（）</li>\n</ol>\n<h3 id=\"2-1-constructor\"><a href=\"#2-1-constructor\" class=\"headerlink\" title=\"2.1 constructor\"></a>2.1 constructor</h3><p><strong>数据的初始化。</strong></p>\n<p>接收 props 和 context，当想在函数内使用这两个参数需要在 super 传入参数，当使用 constructor 时必须使用 super，否则可能会有 this 的指向问题，如果不初始化 state 或者不进行方法绑定，则可以不为组件实现构造函数；</p>\n<p>避免将 props 的值复制给 state！这是一个常见的错误：</p>\n<pre><code class=\"js\">constructor(props) &#123;\n super(props);\n // 不要这样做\n this.state = &#123; color: props.color &#125;;\n&#125;\n</code></pre>\n<p>如此做毫无必要（可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。</p>\n<p>现在我们通常不会使用 <code>constructor</code> 属性，而是改用类加箭头函数的方法，来替代 <code>constructor</code></p>\n<p>例如，我们可以这样初始化 <code>state</code></p>\n<pre><code class=\"js\">state = &#123;\n    count: 0,\n&#125;;\n</code></pre>\n<h3 id=\"2-2-componentWillMount（即将废弃）\"><a href=\"#2-2-componentWillMount（即将废弃）\" class=\"headerlink\" title=\"2.2 componentWillMount（即将废弃）\"></a>2.2 componentWillMount（即将废弃）</h3><p><strong>该方法只在挂载的时候调用一次，表示组件将要被挂载，并且在 <code>render</code> 方法之前调用。</strong></p>\n<blockquote>\n<p>如果存在 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 就不会执行生命周期<code>componentWillMount</code>。</p>\n</blockquote>\n<p>​ 在服务端渲染唯一会调用的函数，代表已经初始化数据但是没有渲染 dom，因此在此方法中同步调用 <code>setState()</code> 不会触发额外渲染。</p>\n<p><strong>这个方法在 React 18 版本中将要被废弃，官方解释是在 React 异步机制下，如果滥用这个钩子可能会有 Bug</strong></p>\n<h3 id=\"2-3-static-getDerivedStateFromProps（新钩子）\"><a href=\"#2-3-static-getDerivedStateFromProps（新钩子）\" class=\"headerlink\" title=\"2.3 static getDerivedStateFromProps（新钩子）\"></a>2.3 static getDerivedStateFromProps（新钩子）</h3><p><strong>从 props 获取 state。</strong></p>\n<p>替代了<code>componentWillReceiveProps，</code>此方法适用于<a href=\"https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state\">罕见的用例</a>，即 state 的值在任何时候都取决于 props。</p>\n<p>这个是 React 新版本中新增的 2 个钩子之一，据说很少用。</p>\n<ol>\n<li><p>首先，该函数会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用；</p>\n</li>\n<li><p>该函数必须是静态的；</p>\n</li>\n<li><p>给组件传递的数据（props）以及组件状态（state），会作为参数到这个函数中；</p>\n</li>\n<li><p>该函数也必须有返回值，返回一个 Null 或者 state 对象。因为初始化和后续更新都会执行这个方法，因此在这个方法返回 state 对象，就相当于将原来的 state 进行了覆盖，所以倒是修改状态不起作用。</p>\n</li>\n</ol>\n<blockquote>\n<p>注意：<code>state</code> 的值在任何时候都取决于传入的 <code>props</code> ，不会再改变</p>\n</blockquote>\n<p>如下</p>\n<pre><code class=\"js\">static getDerivedStateFromProps(props, state) &#123;\n    return null\n&#125;\nReactDOM.render(&lt;Count count=&quot;109&quot;/&gt;,document.querySelector(&#39;.test&#39;))\n</code></pre>\n<p><code>count</code> 的值不会改变，一直是 109</p>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/b331d0e4b398\">React 的生命周期 - 简书</a></p>\n<p>老版本中的 componentWillReceiveProps()方法判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。</p>\n<p>这两者最大的不同就是:<br>在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。</p>\n<ol>\n<li>在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。</li>\n<li>而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。</li>\n</ol>\n</blockquote>\n<h3 id=\"2-4-render\"><a href=\"#2-4-render\" class=\"headerlink\" title=\"2.4 render\"></a>2.4 render</h3><p><strong>class 组件中唯一必须实现的方法。</strong></p>\n<blockquote>\n<p>render 函数会插入 jsx 生成的 dom 结构，react 会生成一份虚拟 dom 树，在每一次组件更新时，在此 react 会通过其 diff 算法比较更新前后的新旧 DOM 树，比较以后，找到最小的有差异的 DOM 节点，并重新渲染。</p>\n</blockquote>\n<blockquote>\n<p>注意：避免在 <code>render</code> 中使用 <code>setState</code> ，否则会死循环</p>\n</blockquote>\n<p>当 render 被调用时，他会检查 this.props.和 this.state 的变化并返回以下类型之一：</p>\n<ol>\n<li>通过 jsx 创建的 react 元素</li>\n<li>数组或者 fragments：使得 render 可以返回多个元素</li>\n<li>Portals:可以渲染子节点到不同的 dom 树上</li>\n<li>字符串或数值类型：他们在 dom 中会被渲染为文本节点</li>\n<li>布尔类型或者 null：什么都不渲染</li>\n</ol>\n<h3 id=\"2-5-componentDidMount\"><a href=\"#2-5-componentDidMount\" class=\"headerlink\" title=\"2.5 componentDidMount\"></a>2.5 componentDidMount</h3><p><strong>在组件挂在后（插入到 dom 树中）后立即调用</strong></p>\n<p><code>componentDidMount</code> 的执行意味着初始化挂载操作已经基本完成，它主要用于组件挂载完成后做某些操作</p>\n<p>这个挂载完成指的是：组件插入 DOM tree</p>\n<p>​ 可以在这里调用 Ajax 请求，返回的数据可以通过 setState 使组件重新渲染，或者添加订阅，但是要在 conponentWillUnmount 中取消订阅</p>\n<h3 id=\"2-6-初始化阶段总结\"><a href=\"#2-6-初始化阶段总结\" class=\"headerlink\" title=\"2.6 初始化阶段总结\"></a>2.6 初始化阶段总结</h3><p>执行顺序 <code>constructor</code> -&gt; <code>getDerivedStateFromProps</code> 或者 <code>componentWillMount</code> -&gt; <code>render</code> -&gt; <code>componentDidMount</code></p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/ea2d0052b360a8aed3ea84796b601d118ce5be13.png\" alt=\"image-20221023223048451\"></p>\n<h2 id=\"3-更新阶段\"><a href=\"#3-更新阶段\" class=\"headerlink\" title=\"3.更新阶段\"></a>3.更新阶段</h2><p><strong>当组件的 props 或 state 发生变化时会触发更新。</strong></p>\n<p><strong>旧生命周期：</strong></p>\n<ol>\n<li><p>componentWillReceiveProps (nextProps)——————可以用但是不建议使用</p>\n</li>\n<li><p>shouldComponentUpdate（nextProps,nextState）</p>\n</li>\n<li><p>componetnWillUpdate（nextProps,nextState）—————-可以用但是不建议使用</p>\n</li>\n<li><p>render（）</p>\n</li>\n<li><p>componentDidUpdate（prevProps,precState,snapshot）</p>\n</li>\n</ol>\n<p><strong>新生命周期：</strong></p>\n<ol>\n<li>static getDerivedStateFromProps（nextProps, prevState）</li>\n<li>shouldComponentUpdate（nextProps,nextState）</li>\n<li>render（）</li>\n<li>getSnapshotBeforeUpdate（prevProps,prevState）</li>\n<li>componentDidUpdate（prevProps,precState,snapshot）</li>\n</ol>\n<h3 id=\"3-1-componentWillReceiveProps-即将废弃\"><a href=\"#3-1-componentWillReceiveProps-即将废弃\" class=\"headerlink\" title=\"3.1 componentWillReceiveProps (即将废弃)\"></a>3.1 componentWillReceiveProps (即将废弃)</h3><p><strong>在已挂载的组件接收新的 props 之前调用。</strong></p>\n<p>通过对比 nextProps 和 this.props，将 nextProps 的 state 为当前组件的 state，从而重新渲染组件，可以在此方法中使用 this.setState 改变 state。</p>\n<pre><code class=\"js\">componentWillReceiveProps (nextProps) &#123;\n    nextProps.openNotice !== this.props.openNotice&amp;&amp;this.setState(&#123;\n        openNotice:nextProps.openNotice\n    &#125;，() =&gt; &#123;\n      console.log(this.state.openNotice:nextProps)\n      //将state更新为nextProps,在setState的第二个参数（回调）可以打         印出新的state\n    &#125;)\n&#125;\n</code></pre>\n<blockquote>\n<p>请注意，如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法。如果只想处理更改，请确保进行当前值与变更值的比较。</p>\n<p>React 不会针对初始 props 调用 UNSAFE_componentWillReceiveProps()。组件只会在组件的 props 更新时调用此方法。调用 this.setState() 通常不会触发该生命周期。</p>\n</blockquote>\n<h3 id=\"3-2-shouldComponentUpdate\"><a href=\"#3-2-shouldComponentUpdate\" class=\"headerlink\" title=\"3.2 shouldComponentUpdate\"></a>3.2 shouldComponentUpdate</h3><p>在渲染之前被调用，默认返回为 true。</p>\n<p>​ 返回值是判断组件的输出是否受当前 state 或 props 更改的影响，默认每次 state 发生变化都重新渲染，首次渲染或使用 forceUpdate(使用<code>this.forceUpdate()</code>)时不被调用。</p>\n<blockquote>\n<p>他主要用于性能优化，会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。不建议深层比较，会影响性能。如果返回 false，则不会调用 componentWillUpdate、render 和 componentDidUpdate</p>\n</blockquote>\n<ul>\n<li>唯一用于控制组件重新渲染的生命周期，由于在 react 中，setState 以后，state 发生变化，组件会进入重新渲染的流程，在这里 return false 可以阻止组件的更新，但是不建议，建议使用 PureComponent</li>\n<li>因为 react 父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断</li>\n</ul>\n<h3 id=\"3-3-componentWillUpdate-即将废弃\"><a href=\"#3-3-componentWillUpdate-即将废弃\" class=\"headerlink\" title=\"3.3 componentWillUpdate (即将废弃)\"></a>3.3 componentWillUpdate (即将废弃)</h3><p><strong>当组件接收到新的 props 和 state 会在渲染前调用，初始渲染不会调用该方法。</strong></p>\n<p>​ shouldComponentUpdate 返回 true 以后，组件进入重新渲染的流程，进入 componentWillUpdate，不能在这使用 setState，在函数返回之前不能执行任何其他更新组件的操作</p>\n<blockquote>\n<p>此方法可以替换为 <code>componentDidUpdate()</code>。如果你在此方法中读取 DOM 信息（例如，为了保存滚动位置），则可以将此逻辑移至 <code>getSnapshotBeforeUpdate()</code> 中。</p>\n</blockquote>\n<h3 id=\"3-4-getSnapshotBeforeUpdate（新钩子）\"><a href=\"#3-4-getSnapshotBeforeUpdate（新钩子）\" class=\"headerlink\" title=\"3.4 getSnapshotBeforeUpdate（新钩子）\"></a>3.4 getSnapshotBeforeUpdate（新钩子）</h3><p><strong>在最近一次的渲染输出之前被提交之前调用，也就是即将挂载时调用，替换 componetnWillUpdate。</strong></p>\n<p>相当于淘宝购物的快照，会保留下单前的商品内容，在 React 中就相当于是 即将更新前的状态</p>\n<p>它可以使组件在 DOM 真正更新之前捕获一些信息（例如滚动位置），此生命周期返回的任何值都会作为参数传递给 <code>componentDidUpdate()</code>。如不需要传递任何值，那么请返回 null</p>\n<blockquote>\n<p>和 componentWillUpdate 的区别</p>\n<ul>\n<li>在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在 componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。</li>\n<li>getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-5-componentDidUpdate\"><a href=\"#3-5-componentDidUpdate\" class=\"headerlink\" title=\"3.5 componentDidUpdate\"></a>3.5 componentDidUpdate</h3><p><strong>组件在更新完毕后会立即被调用，首次渲染不会调用</strong></p>\n<p>可以在该方法调用 setState，但是要包含在条件语句中，否则一直更新会造成死循环。</p>\n<p>当组件更新后，可以在此处对 DOM 进行操作。如果对更新前后的 props 进行了比较，可以进行网络请求。（当 props 未发生变化时，则不会执行网络请求）。</p>\n<pre><code class=\"javascript\">componentDidUpdate(prevProps,prevState,snapshotValue) &#123;\n  // 典型用法（不要忘记比较 props）：\n  if (this.props.userID !== prevProps.userID) &#123;\n    this.fetchData(this.props.userID);\n  &#125;\n&#125;\n</code></pre>\n<blockquote>\n<p>如果组件实现了 <code>getSnapshotBeforeUpdate()</code> 生命周期（不常用），则它的返回值将作为 <code>componentDidUpdate()</code> 的第三个参数 “snapshotValue” 参数传递。否则此参数将为 undefined。如果返回 false 就不会调用这个函数。</p>\n</blockquote>\n<h3 id=\"3-6-getSnapshotBeforeUpdate-使用场景\"><a href=\"#3-6-getSnapshotBeforeUpdate-使用场景\" class=\"headerlink\" title=\"3.6 getSnapshotBeforeUpdate 使用场景\"></a>3.6 getSnapshotBeforeUpdate 使用场景</h3><p>在一个区域内，定时的输出以行话，如果内容大小超过了区域大小，就出现滚动条，但是内容不进行移动</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/0ce6f820adb5b75e44b1df2332caa58bb8eaa257.gif\" alt=\"BeforeGender\"></p>\n<p>如上面的动图：区域内部的内容展现没有变化，但是可以看见滚动条在变化，也就是说上面依旧有内容在输出，只不过不在这个区域内部展现。</p>\n<p>1.首先我们先实现定时输出内容</p>\n<p>我们可以使用 state 状态，改变新闻后面的值，但是为了同时显示这些内容，我们应该为 state 的属性定义一个数组。并在创建组件之后开启一个定时器，不断的进行更新 state。更新渲染组件</p>\n<pre><code class=\"js\">class New extends React.Component &#123;\n    state = &#123; num: [] &#125;;\n\n    //在组件创建之后,开启一个定时任务\n    componentDidMount() &#123;\n        setInterval(() =&gt; &#123;\n            let &#123; num &#125; = this.state;\n            const news = num.length + 1;\n            this.setState(&#123; num: [news, ...num] &#125;);\n        &#125;, 2000);\n    &#125;\n\n    render() &#123;\n        return (\n            &lt;div ref=&quot;list&quot; className=&quot;list&quot;&gt;\n                &#123;this.state.num.map((n, index) =&gt; &#123;\n                    return (\n                        &lt;div className=&quot;news&quot; key=&#123;index&#125;&gt;\n                            新闻&#123;n&#125;\n                        &lt;/div&gt;\n                    );\n                &#125;)&#125;\n            &lt;/div&gt;\n        );\n    &#125;\n&#125;\nReactDOM.render(&lt;New /&gt;, document.getElementById(&quot;div&quot;));\n</code></pre>\n<p>2.接下来就是控制滚动条了</p>\n<p>我们在组件渲染到 DOM 之前获取组件的高度，然后用组件渲染之后的高度减去之前的高度就是一条新的内容的高度，这样在不断的累加到滚动条位置上。</p>\n<pre><code class=\"js\">getSnapshotBeforeUpdate()&#123;\n    return this.refs.list.scrollHeight;\n&#125;\n\ncomponentDidUpdate(preProps,preState,height)&#123;\n    this.refs.list.scrollTop += (this.refs.list.scrollHeight - height);\n&#125;\n</code></pre>\n<p>这样就实现了这个功能。</p>\n<h2 id=\"4-卸载组件\"><a href=\"#4-卸载组件\" class=\"headerlink\" title=\"4.卸载组件\"></a>4.卸载组件</h2><p><strong>当组件从 DOM 中移除时会调用如下方法</strong></p>\n<h3 id=\"4-1-componentWillUnmount\"><a href=\"#4-1-componentWillUnmount\" class=\"headerlink\" title=\"4.1 componentWillUnmount\"></a>4.1 componentWillUnmount</h3><p><strong>在组件卸载和销毁之前调用</strong></p>\n<blockquote>\n<p>使用这样的方式去卸载<code>ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))</code></p>\n</blockquote>\n<p>​ 在这执行必要的清理操作，例如，清除 timer（setTimeout,setInterval），取消网络请求，或者取消在 componentDidMount 的订阅，移除所有监听</p>\n<p>有时候我们会碰到这个 warning:</p>\n<pre><code class=\"js\">Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a   no-op. Please check the code for the undefined component.\n</code></pre>\n<p>原因：因为你在组件中的 ajax 请求返回 setState,而你组件销毁的时候，请求还未完成，因此会报 warning</p>\n<p>解决方法：</p>\n<pre><code class=\"javascript\">componentDidMount() &#123;\n    this.isMount === true\n    axios.post().then((res) =&gt; &#123;\n    this.isMount &amp;&amp; this.setState(&#123;   // 增加条件ismount为true时\n      aaa:res\n    &#125;)\n&#125;)\n&#125;\ncomponentWillUnmount() &#123;\n    this.isMount === false\n&#125;\n</code></pre>\n<p><code>componentWillUnmount()</code> 中不应调用 <code>setState()</code>，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p>\n",
            "tags": [
                "React"
            ]
        },
        {
            "id": "http://example.com/2023/09/24/03.react%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/",
            "url": "http://example.com/2023/09/24/03.react%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/",
            "title": "React-事件处理",
            "date_published": "2023-09-24T10:57:52.000Z",
            "content_html": "<h1 id=\"03-【事件处理】\"><a href=\"#03-【事件处理】\" class=\"headerlink\" title=\"03 【事件处理】\"></a>03 【事件处理】</h1><blockquote>\n<p>React 的事件是通过 onXxx 属性指定事件处理函数</p>\n<p>React 使用的是自定义事件，而不是原生的 DOM 事件</p>\n<p>React 的事件是通过事件委托方式处理的（为了更加的高效）</p>\n<p>可以通过事件的 <code>event.target</code>获取发生的 DOM 元素对象，可以尽量减少 <code>refs</code>的使用</p>\n<p>事件中必须返回的是函数</p>\n</blockquote>\n<h2 id=\"1-React-事件\"><a href=\"#1-React-事件\" class=\"headerlink\" title=\"1.React 事件\"></a>1.React 事件</h2><p>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同：</p>\n<ul>\n<li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li>\n<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li>\n</ul>\n<p>例如，传统的 HTML：</p>\n<pre><code class=\"html\">&lt;button onclick=&quot;activateLasers()&quot;&gt;Activate Lasers&lt;/button&gt;\n</code></pre>\n<p>在 React 中略微不同：</p>\n<pre><code class=\"html\">&lt;button onClick=&quot;&#123;activateLasers&#125;&quot;&gt;Activate Lasers&lt;/button&gt;\n</code></pre>\n<p>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式地使用 <code>preventDefault</code>。例如，传统的 HTML 中阻止表单的默认提交行为，你可以这样写：</p>\n<pre><code class=\"js\">&lt;form onsubmit=&quot;console.log(&#39;You clicked submit.&#39;); return false&quot;&gt;\n    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>\n<p>在 React 中，可能是这样的：</p>\n<pre><code class=\"js\">function Form() &#123;\n    function handleSubmit(e) &#123;\n        e.preventDefault();\n        console.log(&quot;You clicked submit.&quot;);\n    &#125;\n\n    return (\n        &lt;form onSubmit=&#123;handleSubmit&#125;&gt;\n            &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;\n        &lt;/form&gt;\n    );\n&#125;\n</code></pre>\n<p>在这里，<code>e</code> 是一个合成事件。React 根据 <a href=\"https://www.w3.org/TR/DOM-Level-3-Events/\">W3C 规范</a>来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。React 事件与原生事件不完全相同。如果想了解更多，请查看 <a href=\"https://zh-hans.reactjs.org/docs/events.html\"><code>SyntheticEvent</code></a> 参考指南。</p>\n<p>使用 React 时，你一般不需要使用 <code>addEventListener</code> 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。</p>\n<h2 id=\"2-类式组件绑定事件\"><a href=\"#2-类式组件绑定事件\" class=\"headerlink\" title=\"2.类式组件绑定事件\"></a>2.类式组件绑定事件</h2><p>当你使用 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes\">ES6 class</a> 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 <code>Toggle</code> 组件会渲染一个让用户切换开关状态的按钮：</p>\n<pre><code class=\"js\">class Toggle extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123;isToggleOn: true&#125;;\n    // 为了在回调中使用 `this`，这个绑定是必不可少的    \tthis.handleClick = this.handleClick.bind(this);  &#125;\n\n  handleClick() &#123;\n    this.setState(prevState =&gt; (&#123;\n      isToggleOn: !prevState.isToggleOn\n    &#125;));\n  &#125;\n\n  render() &#123;\n    return (\n      &lt;button onClick=&#123;this.handleClick&#125;&gt;\n        &#123;this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;&#125;\n      &lt;/button&gt;\n    );\n  &#125;\n&#125;\n</code></pre>\n<p><a href=\"https://codepen.io/gaearon/pen/xEmzGg?editors=0010\"><strong>在 CodePen 上尝试</strong></a></p>\n<p>你必须谨慎对待 JSX 回调函数中的 <code>this</code>，在 JavaScript 中，class 的方法默认不会<a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\">绑定</a> <code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code>。</p>\n<p>这并不是 React 特有的行为；这其实与 <a href=\"https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/\">JavaScript 函数工作原理</a>有关。通常情况下，如果你没有在方法后面添加 <code>()</code>，例如 <code>onClick=&#123;this.handleClick&#125;</code>，你应该为这个方法绑定 <code>this</code>。</p>\n<p>如果觉得使用 <code>bind</code> 很麻烦，这里有两种方式可以解决。你可以使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields#public_instance_fields\">public class fields 语法</a> to correctly bind callbacks:</p>\n<pre><code class=\"js\">class LoggingButton extends React.Component &#123;\n    // This syntax ensures `this` is bound within handleClick.\n    handleClick = () =&gt; &#123;\n        console.log(&quot;this is:&quot;, this);\n    &#125;;\n    render() &#123;\n        return &lt;button onClick=&#123;this.handleClick&#125;&gt;Click me&lt;/button&gt;;\n    &#125;\n&#125;\n</code></pre>\n<p><a href=\"https://github.com/facebookincubator/create-react-app\">Create React App</a> 默认启用此语法。</p>\n<p>如果你没有使用 class fields 语法，你可以在回调中使用<a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭头函数</a>：</p>\n<pre><code class=\"js\">class LoggingButton extends React.Component &#123;\n    handleClick() &#123;\n        console.log(&quot;this is:&quot;, this);\n    &#125;\n\n    render() &#123;\n        // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n        return &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;Click me&lt;/button&gt;;\n    &#125;\n&#125;\n</code></pre>\n<p>此语法问题在于每次渲染 <code>LoggingButton</code> 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。</p>\n<h2 id=\"3-向事件处理程序传递参数\"><a href=\"#3-向事件处理程序传递参数\" class=\"headerlink\" title=\"3.向事件处理程序传递参数\"></a>3.向事件处理程序传递参数</h2><p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 <code>id</code> 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p>\n<pre><code class=\"js\">&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;\n&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;\n</code></pre>\n<p>上述两种方式是等价的，分别通过<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭头函数</a>和 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind\"><code>Function.prototype.bind</code></a> 来实现。</p>\n<p>在这两种情况下，React 的事件对象 <code>e</code> 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>\n<h2 id=\"4-收集表单数据\"><a href=\"#4-收集表单数据\" class=\"headerlink\" title=\"4.收集表单数据\"></a>4.收集表单数据</h2><p>首先我们先来创建一个简单的表单组件：</p>\n<pre><code class=\"jsx\">import React from &quot;react&quot;;\n\nconst MyForm = () =&gt; &#123;\n    return (\n        &lt;form&gt;\n            &lt;div&gt;\n                用户名 &lt;input type=&quot;text&quot; /&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                密码 &lt;input type=&quot;password&quot; /&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                电子邮件 &lt;input type=&quot;email&quot; /&gt;\n            &lt;/div&gt;\n\n            &lt;div&gt;\n                &lt;button&gt;提交&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/form&gt;\n    );\n&#125;;\n\nexport default MyForm;\n</code></pre>\n<p>首先使用 React 定义表单和之前传统网页中的表单有一些区别，传统网页中 form 需要指定 action 和 method 两个属性，而表单项也必须要指定 name 属性，这些属性都是提交表单所必须的。但是在 React 中定义表单时，这些属性通通都可以不指定，因为 React 中的表单所有的功能都需要通过代码来控制，包括获取表单值和提交表单，所以这些东西都可以在函数中指定并通过 AJAX 发送请求，无需直接在表单中设置。</p>\n<p>首先我们来研究一下如何获取表单中的用户所填写的内容，要获取用户所填写的内容我们必须要监听表单 onChange 事件，在表单项发生变化时获取其中的内容，在响应函数中通过事件对象的 target.value 来获取用户填写的内容。事件响应函数大概是这个样子：</p>\n<pre><code class=\"jsx\">const nameChangeHandler = (e) =&gt; &#123;\n    //e.target.value 表示当前用户输入的值\n&#125;;\n</code></pre>\n<p>然后我们再将该函数设置为 input 元素的 onChange 事件的响应函数：</p>\n<pre><code class=\"jsx\">&lt;div&gt;\n    用户名 &lt;input type=&quot;text&quot; onChange=&#123;nameChangeHandler&#125; /&gt;\n&lt;/div&gt;\n</code></pre>\n<p>这样一来当用户输入内容时，nameChangeHandler 就会被触发，从而通过 e.target.value 来获取用户输入的值。通常我们还会为表单项创建一个 state 用来存储值：</p>\n<pre><code class=\"jsx\">const [inputName, setInputName] = useState(&quot;&quot;);\nconst nameChangeHandler = (e) =&gt; &#123;\n    //e.target.value 表示当前用户输入的值\n    setInputName(e.target.value);\n&#125;;\n</code></pre>\n<p>上例中用户名存储到了变量 inputName 中，inputName 也会设置为对应表单项的 value 属性值，这样一来当 inputName 发生变化时，表单项中的内容也会随之改变：</p>\n<pre><code class=\"jsx\">&lt;div&gt;\n    用户名 &lt;input type=&quot;text&quot; onChange=&#123;nameChangeHandler&#125; value=&#123;inputName&#125; /&gt;\n&lt;/div&gt;\n</code></pre>\n<p>如此设置后，当用户输入内容后会触发 onChange 事件从而调用 nameChangeHandler 函数，在函数内部调用了 setInputName 设置了用户输入的用户名。换句话说用户在表单中输入内容会影响到 state 的值，同时当我们修改 state 的值时，由于表单项的 value 属性值指向了 state，表单也会随 state 值一起改变。这种绑定方式我们称为双向绑定，即表单会改变 state，state 也可以改变表单，在开发中使用双向绑定的表单项是最佳实践。</p>\n<h2 id=\"5-受控和非受控组件\"><a href=\"#5-受控和非受控组件\" class=\"headerlink\" title=\"5.受控和非受控组件\"></a>5.受控和非受控组件</h2><p>先来说说受控组件：</p>\n<p>使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p>\n<pre><code class=\"js\">saveName = (event) =&gt;&#123;\n    this.setState(&#123;name:event.target.value&#125;);\n&#125;\n\nsavePwd = (event) =&gt; &#123;\n    this.setState(&#123;pwd:event.target.value&#125;);\n&#125;\n\nrender() &#123;\n    return (\n        &lt;form action=&quot;http://www.baidu.com&quot; onSubmit=&#123;this.login&#125;&gt;\n            用户名：&lt;input value=&#123;this.state.name&#125; onChange=&#123;this.saveName&#125; type = &quot;text&quot; /&gt;\n            密码&lt;input value=&#123;this.state.pwd&#125; onChange=&#123;this.savePwd&#125; type = &quot;password&quot;/&gt;\n            &lt;button&gt;登录&lt;/button&gt;\n        &lt;/form&gt;\n    )\n&#125;\n</code></pre>\n<p>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。由于 <code>onchange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p>\n<p>对于受控组件来说，输入的值始终由 React 的 state 驱动。</p>\n<p><strong>非受控组件：</strong></p>\n<p>非受控组件其实就是表单元素的值不会更新 state。输入数据都是现用现取的。</p>\n<p>如下：下面并没有使用 state 来控制属性，使用的是事件来控制表单的属性值。</p>\n<blockquote>\n<p>表单提交同样需要通过事件来处理，提交表单的事件通过 form 标签的 onSubmit 事件来绑定，处理表单的方式因情况而已，但是一定要注意，必须要取消默认行为，否则会触发表单的默认提交行为：</p>\n</blockquote>\n<pre><code class=\"js\">class Login extends React.Component &#123;\n    login = (event) =&gt; &#123;\n        event.preventDefault(); //阻止表单默认事件\n        console.log(this.name.value);\n        console.log(this.pwd.value);\n    &#125;;\n    render() &#123;\n        return (\n            &lt;form action=&quot;http://www.baidu.com&quot; onSubmit=&#123;this.login&#125;&gt;\n                用户名：\n                &lt;input ref=&#123;(e) =&gt; (this.name = e)&#125; type=&quot;text&quot; name=&quot;username&quot; /&gt;\n                密码： &lt;input ref=&#123;(e) =&gt; (this.pwd = e)&#125; type=&quot;password&quot; name=&quot;password&quot; /&gt;\n                &lt;button&gt;登录&lt;/button&gt;\n            &lt;/form&gt;\n        );\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"5-函数的柯里化\"><a href=\"#5-函数的柯里化\" class=\"headerlink\" title=\"5.函数的柯里化\"></a>5.函数的柯里化</h2><p><strong>高级函数</strong></p>\n<ol>\n<li><p>如果函数的参数是函数</p>\n</li>\n<li><p>如果函数返回一个函数</p>\n</li>\n</ol>\n<p>通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</p>\n<p>如下，我们将上面的案例简化，创建高级函数：</p>\n<pre><code class=\"js\">class Login extends React.Component &#123;\n    state = &#123; name: &quot;&quot;, pwd: &quot;&quot; &#125;;\n\n    //返回一个函数\n    saveType = (type) =&gt; &#123;\n        return (event) =&gt; &#123;\n            this.setState(&#123; [type]: event.target.value &#125;);\n        &#125;;\n    &#125;;\n\n    //因为事件中必须是一个函数，所以返回的也是一个函数，这样就符合规范了\n    render() &#123;\n        return (\n            &lt;form&gt;\n                &lt;input onChange=&#123;this.saveType(&quot;name&quot;)&#125; type=&quot;text&quot; /&gt;\n                &lt;button&gt;登录&lt;/button&gt;\n            &lt;/form&gt;\n        );\n    &#125;\n&#125;\n\nReactDOM.render(&lt;Login /&gt;, document.getElementById(&quot;div&quot;));\n</code></pre>\n<p>不使用函数柯里化</p>\n<pre><code class=\"js\">class Login extends React.Component &#123;\n    state = &#123; name: &quot;&quot;, pwd: &quot;&quot; &#125;;\n\n    //返回一个函数\n    saveType = (type, event) =&gt; &#123;\n        this.setState(&#123; [type]: event.target.value &#125;);\n    &#125;;\n\n    //因为事件中必须是一个函数，所以返回的也是一个函数，这样就符合规范了\n    render() &#123;\n        return (\n            &lt;form&gt;\n                &lt;input onChange=&#123;(event) =&gt; this.saveType(&quot;name&quot;, event)&#125; type=&quot;text&quot; /&gt;\n                &lt;button&gt;登录&lt;/button&gt;\n            &lt;/form&gt;\n        );\n    &#125;\n&#125;\n\nReactDOM.render(&lt;Login /&gt;, document.getElementById(&quot;div&quot;));\n</code></pre>\n",
            "tags": [
                "React"
            ]
        },
        {
            "id": "http://example.com/2023/09/24/02.react%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/",
            "url": "http://example.com/2023/09/24/02.react%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B/",
            "title": "React-面向组件编程",
            "date_published": "2023-09-24T10:57:52.000Z",
            "content_html": "<h1 id=\"02-【面向组件编程】\"><a href=\"#02-【面向组件编程】\" class=\"headerlink\" title=\"02 【面向组件编程】\"></a>02 【面向组件编程】</h1><h2 id=\"1-组件的使用\"><a href=\"#1-组件的使用\" class=\"headerlink\" title=\"1.组件的使用\"></a>1.组件的使用</h2><p>当应用是以多组件的方式实现，这个应用就是一个组件化的应用</p>\n<p>只有两种方式的组件</p>\n<ul>\n<li>函数组件</li>\n<li>类式组件</li>\n</ul>\n<blockquote>\n<p><strong>注意：</strong></p>\n<ol>\n<li>组件名必须是首字母大写（React 会将以小写字母开头的组件视为原生 DOM 标签。例如，&lt; div &#x2F;&gt;<code>代表 HTML 的 div 标签，而</code>&lt; Weclome &#x2F;&gt; 则代表一个组件，并且需在作用域内使用 <code>Welcome</code>）</li>\n<li>虚拟 DOM 元素只能有一个根元素</li>\n<li>虚拟 DOM 元素必须有结束标签 <code>&lt; /&gt;</code></li>\n</ol>\n</blockquote>\n<p><strong>渲染类组件标签的基本流程</strong></p>\n<ol>\n<li>React 内部会创建组件实例对象</li>\n<li>调用<code>render()</code>得到虚拟 DOM ,并解析为真实 DOM</li>\n<li>插入到指定的页面元素内部</li>\n</ol>\n<h3 id=\"1-1-函数式组件\"><a href=\"#1-1-函数式组件\" class=\"headerlink\" title=\"1.1 函数式组件\"></a>1.1 函数式组件</h3><p>定义组件最简单的方式就是编写 JavaScript 函数：</p>\n<pre><code class=\"js\">//1.创建函数式组件\nfunction MyComponent(props) &#123;\n    console.log(this); //此处的this是undefined，因为babel编译后开启了严格模式\n    return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;/h2&gt;;\n&#125;\n\n//2.渲染组件到页面\nReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(&quot;test&quot;));\n</code></pre>\n<p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p>\n<p>让我们来回顾一下这个例子中发生了什么：</p>\n<ol>\n<li><p>React 解析组件标签，找到了 MyComponent 组件。</p>\n</li>\n<li><p>发现组件是使用函数定义的，随后调用该函数，将返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中。</p>\n</li>\n</ol>\n<p><strong>注意：</strong> <strong>组件名称必须以大写字母开头。</strong></p>\n<p>React 会将以小写字母开头的组件视为原生 DOM 标签。例如，<code>&lt;div /&gt;</code> 代表 HTML 的 div 标签，而 <code>&lt;Welcome /&gt;</code> 则代表一个组件，并且需在作用域内使用 <code>Welcome</code>。</p>\n<p>你可以在<a href=\"https://zh-hans.reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized\">深入 JSX</a> 中了解更多关于此规范的原因。</p>\n<h3 id=\"1-2-类式组件\"><a href=\"#1-2-类式组件\" class=\"headerlink\" title=\"1.2 类式组件\"></a>1.2 类式组件</h3><blockquote>\n<p><strong>将函数组件转换成 class 组件</strong></p>\n<p>通过以下五步将 <code>Clock</code> 的函数组件转成 class 组件：</p>\n<ol>\n<li>创建一个同名的 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes\">ES6 class</a>，并且继承于 <code>React.Component</code>。</li>\n<li>添加一个空的 <code>render()</code> 方法。</li>\n<li>将函数体移动到 <code>render()</code> 方法之中。</li>\n<li>在 <code>render()</code> 方法中使用 <code>this.props</code> 替换 <code>props</code>。</li>\n<li>删除剩余的空函数声明。</li>\n</ol>\n</blockquote>\n<pre><code class=\"js\">class MyComponent extends React.Component &#123;\n    render() &#123;\n        console.log(&quot;render中的this:&quot;, this);\n        return &lt;h2&gt;我是用类定义的组件(适用于【复杂组件】的定义)&lt;/h2&gt;;\n    &#125;\n&#125;\n\nReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(&quot;test&quot;));\n</code></pre>\n<p>每次组件更新时 <code>render</code> 方法都会被调用，但只要在相同的 DOM 节点中渲染 <code>&lt;MyComponent/&gt;</code> ，就仅有一个 <code>MyComponent</code> 组件的 class 实例被创建使用。这就使得我们可以使用如 state 或生命周期方法等很多其他特性。</p>\n<p><strong>执行过程：</strong></p>\n<ol>\n<li><p>React 解析组件标签，找到相应的组件</p>\n</li>\n<li><p>发现组件是类定义的，随后 new 出来的类的实例，并通过该实例调用到原型上的 render 方法</p>\n</li>\n<li><p>将 render 返回的虚拟 DOM 转化为真实的 DOM,随后呈现在页面中</p>\n</li>\n</ol>\n<h3 id=\"1-3-组合组件\"><a href=\"#1-3-组合组件\" class=\"headerlink\" title=\"1.3 组合组件\"></a>1.3 组合组件</h3><p>组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。按钮，表单，对话框，甚至整个屏幕的内容：在 React 应用程序中，这些通常都会以组件的形式表示。</p>\n<p>例如，我们可以创建一个可以多次渲染 <code>Welcome</code> 组件的 <code>App</code> 组件：</p>\n<pre><code class=\"js\">function Welcome(props) &#123;\n    return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;\n&#125;\n\nfunction App() &#123;\n    return (\n        &lt;div&gt;\n            &lt;Welcome name=&quot;Sara&quot; /&gt;\n            &lt;Welcome name=&quot;Cahal&quot; /&gt;\n            &lt;Welcome name=&quot;Edite&quot; /&gt;\n        &lt;/div&gt;\n    );\n&#125;\n</code></pre>\n<p><img src=\"https://i0.hdslb.com/bfs/album/61b62685a57a9ebd6162b9d13448aa8d6a74be99.png\" alt=\"image-20221023135154884\"></p>\n<p>通常来说，每个新的 React 应用程序的顶层组件都是 <code>App</code> 组件。但是，如果你将 React 集成到现有的应用程序中，你可能需要使用像 <code>Button</code> 这样的小组件，并自下而上地将这类组件逐步应用到视图层的每一处。</p>\n<h3 id=\"1-4-提取组件\"><a href=\"#1-4-提取组件\" class=\"headerlink\" title=\"1.4 提取组件\"></a>1.4 提取组件</h3><p>将组件拆分为更小的组件。</p>\n<p>例如，参考如下 <code>Comment</code> 组件：</p>\n<pre><code class=\"js\">function formatDate(date) &#123;\n    return date.toLocaleDateString();\n&#125;\n\nfunction Comment(props) &#123;\n    return (\n        &lt;div className=&quot;Comment&quot;&gt;\n            &lt;div className=&quot;UserInfo&quot;&gt;\n                &lt;img className=&quot;Avatar&quot; src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125; /&gt;\n                &lt;div className=&quot;UserInfo-name&quot;&gt;&#123;props.author.name&#125;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div className=&quot;Comment-text&quot;&gt;&#123;props.text&#125;&lt;/div&gt;\n            &lt;div className=&quot;Comment-date&quot;&gt;&#123;formatDate(props.date)&#125;&lt;/div&gt;\n        &lt;/div&gt;\n    );\n&#125;\n\nconst comment = &#123;\n    date: new Date(),\n    text: &quot;I hope you enjoy learning React!&quot;,\n    author: &#123;\n        name: &quot;Hello Kitty&quot;,\n        avatarUrl: &quot;http://placekitten.com/g/64/64&quot;,\n    &#125;,\n&#125;;\n\nReactDOM.render(&lt;Comment date=&#123;comment.date&#125; text=&#123;comment.text&#125; author=&#123;comment.author&#125; /&gt;, document.getElementById(&quot;test&quot;));\n</code></pre>\n<p><strong><a href=\"https://codepen.io/gaearon/pen/VKQwEo?editors=1010\">在 CodePen 上试试</a></strong></p>\n<p>该组件用于描述一个社交媒体网站上的评论功能，它接收 <code>author</code>（对象），<code>text</code> （字符串）以及 <code>date</code>（日期）作为 props。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/09cf8c18c6f756985e0fc0e4436b075fe02b8027.png\" alt=\"image-20221023135735919\"></p>\n<p>该组件由于嵌套的关系，变得难以维护，且很难复用它的各个部分。因此，让我们从中提取一些组件出来。</p>\n<p>首先，我们将提取 <code>Avatar</code> 组件：</p>\n<pre><code class=\"js\">function Avatar(props) &#123;\n    return &lt;img className=&quot;Avatar&quot; src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt;;\n&#125;\n</code></pre>\n<p><code>Avatar</code> 不需知道它在 <code>Comment</code> 组件内部是如何渲染的。因此，我们给它的 props 起了一个更通用的名字：<code>user</code>，而不是 <code>author</code>。</p>\n<p>我们建议从组件自身的角度命名 props，而不是依赖于调用组件的上下文命名。</p>\n<p>我们现在针对 <code>Comment</code> 做些微小调整：</p>\n<pre><code class=\"js\">function Avatar(props) &#123;\n    return &lt;img className=&quot;Avatar&quot; src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt;;\n&#125;\n\nfunction Comment(props) &#123;\n    return (\n        &lt;div className=&quot;Comment&quot;&gt;\n            &lt;div className=&quot;UserInfo&quot;&gt;\n                &lt;Avatar user=&#123;props.author&#125; /&gt;\n                &lt;div className=&quot;UserInfo-name&quot;&gt;&#123;props.author.name&#125;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div className=&quot;Comment-text&quot;&gt;&#123;props.text&#125;&lt;/div&gt;\n            &lt;div className=&quot;Comment-date&quot;&gt;&#123;formatDate(props.date)&#125;&lt;/div&gt;\n        &lt;/div&gt;\n    );\n&#125;\n</code></pre>\n<p>接下来，我们将提取 <code>UserInfo</code> 组件，该组件在用户名旁渲染 <code>Avatar</code> 组件：</p>\n<pre><code class=\"js\">function UserInfo(props) &#123;\n    return (\n        &lt;div className=&quot;UserInfo&quot;&gt;\n            &lt;Avatar user=&#123;props.user&#125; /&gt;\n            &lt;div className=&quot;UserInfo-name&quot;&gt;&#123;props.user.name&#125;&lt;/div&gt;\n        &lt;/div&gt;\n    );\n&#125;\n</code></pre>\n<p>进一步简化 <code>Comment</code> 组件：</p>\n<pre><code class=\"js\">function Avatar(props) &#123;\n    return &lt;img className=&quot;Avatar&quot; src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt;;\n&#125;\n\nfunction UserInfo(props) &#123;\n    return (\n        &lt;div className=&quot;UserInfo&quot;&gt;\n            &lt;Avatar user=&#123;props.user&#125; /&gt;\n            &lt;div className=&quot;UserInfo-name&quot;&gt;&#123;props.user.name&#125;&lt;/div&gt;\n        &lt;/div&gt;\n    );\n&#125;\n\nfunction Comment(props) &#123;\n    return (\n        &lt;div className=&quot;Comment&quot;&gt;\n            &lt;UserInfo user=&#123;props.author&#125; /&gt;\n            &lt;div className=&quot;Comment-text&quot;&gt;&#123;props.text&#125;&lt;/div&gt;\n            &lt;div className=&quot;Comment-date&quot;&gt;&#123;formatDate(props.date)&#125;&lt;/div&gt;\n        &lt;/div&gt;\n    );\n&#125;\n</code></pre>\n<p><strong><a href=\"https://codepen.io/gaearon/pen/rrJNJY?editors=1010\">在 CodePen 上试试</a></strong></p>\n<p>最初看上去，提取组件可能是一件繁重的工作，但是，在大型应用中，构建可复用组件库是完全值得的。根据经验来看，如果 UI 中有一部分被多次使用（<code>Button</code>，<code>Panel</code>，<code>Avatar</code>），或者组件本身就足够复杂（<code>App</code>，<code>FeedStory</code>，<code>Comment</code>），那么它就是一个可提取出独立组件的候选项。</p>\n<h2 id=\"组件实例的三大属性-state-props-refs\"><a href=\"#组件实例的三大属性-state-props-refs\" class=\"headerlink\" title=\"组件实例的三大属性 state props refs\"></a>组件实例的三大属性 state props refs</h2><h2 id=\"2-state\"><a href=\"#2-state\" class=\"headerlink\" title=\"2.state\"></a>2.state</h2><h3 id=\"2-1-基本使用\"><a href=\"#2-1-基本使用\" class=\"headerlink\" title=\"2.1 基本使用\"></a>2.1 基本使用</h3><blockquote>\n<p>我们都说 React 是一个状态机，体现是什么地方呢，就是体现在 state 上，通过与用户的交互，实现不同的状态，然后去渲染 UI,这样就让用户的数据和界面保持一致了。state 是组件的私有属性。</p>\n<p>在 React 中，更新组件的 state，结果就会重新渲染用户界面(不需要操作 DOM),一句话就是说，用户的界面会随着状态的改变而改变。</p>\n<p>state 是组件对象最重要的属性，值是对象（可以包含多个 key-value 的组合）</p>\n<p>简单的说就是组件的状态，也就是该组件所存储的数据</p>\n</blockquote>\n<p><strong>案例</strong>：</p>\n<p>需求：页面显示【今天天气很炎热】，鼠标点击文字的时候，页面更改为【今天天气很凉爽】</p>\n<p>核心代码如下：</p>\n<pre><code class=\"js\">&lt;body&gt;\n    &lt;!-- 准备好容器 --&gt;\n    &lt;div id=&quot;test&quot;&gt;\n\n    &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;!--这里使用了js来创建虚拟DOM--&gt;\n&lt;script type=&quot;text/babel&quot;&gt;\n        //1.创建组件\n        class St extends React.Component&#123;\n            constructor(props)&#123;\n                super(props);\n                //先给state赋值\n                this.state = &#123;isHot:true,win:&quot;ss&quot;&#125;;\n                //找到原型的dem，根据dem函数创建了一个dem1的函数，并且将实例对象的this赋值过去\n                this.dem1 = this.dem.bind(this);\n            &#125;\n            //render会调用1+n次【1就是初始化的时候调用的，n就是每一次修改state的时候调用的】\n            render()&#123; //这个This也是实例对象\n                //如果加dem()，就是将函数的回调值放入这个地方\n                //this.dem这里面加入this，并不是调用，只不过是找到了dem这个函数，在调用的时候相当于直接调用，并不是实例对象的调用\n                return &lt;h1 onClick = &#123;this.dem1&#125;&gt;今天天气很&#123;this.state.isHot?&quot;炎热&quot;:&quot;凉爽&quot;&#125;&lt;/h1&gt;\n            &#125;\n            //通过state的实例调用dem的时候，this就是实例对象\n            dem()&#123;\n                const state =  this.state.isHot;\n                 //状态中的属性不能直接进行更改，需要借助API\n                // this.state.isHot = !isHot; 错误\n                //必须使用setState对其进行修改，并且这是一个合并\n                this.setState(&#123;isHot:!state&#125;);\n            &#125;\n        &#125;\n        // 2.渲染，如果有多个渲染同一个容器，后面的会将前面的覆盖掉\n        ReactDOM.render(&lt;St/&gt;,document.getElementById(&quot;test&quot;));\n&lt;/script&gt;\n</code></pre>\n<p>在<strong>类式组件</strong>的函数中，直接修改<code>state</code>值</p>\n<pre><code class=\"js\">this.state.isHot = false;\n</code></pre>\n<blockquote>\n<p>页面的渲染靠的是<code>render</code>函数</p>\n</blockquote>\n<p>这时候会发现页面内容不会改变，原因是 React 中不建议 <code>state</code>不允许直接修改，而是通过类的原型对象上的方法 <code>setState()</code></p>\n<p><strong>注意：</strong></p>\n<ol>\n<li><p>组件的构造函数，必须要传递一个 props 参数</p>\n</li>\n<li><p>特别关注 this【重点】，类中所有的方法局部都开启了严格模式，如果直接进行调用，this 就是 undefined</p>\n</li>\n<li><p>想要改变 state,需要使用 setState 进行修改，如果只是修改 state 的部分属性，则不会影响其他的属性，这个只是合并并不是覆盖。</p>\n</li>\n</ol>\n<p><strong>在优化过程中遇到的问题</strong></p>\n<ol>\n<li>组件中的 render 方法中的 this 为组件实例对象</li>\n<li>组件自定义方法中由于开启了严格模式，this 指向<code>undefined</code>如何解决<ol>\n<li>通过 bind 改变 this 指向</li>\n<li>推荐采用箭头函数，箭头函数的 <code>this</code> 指向</li>\n</ol>\n</li>\n<li>state 数据不能直接修改或者更新</li>\n</ol>\n<h3 id=\"2-2-setState\"><a href=\"#2-2-setState\" class=\"headerlink\" title=\"2.2 setState()\"></a>2.2 setState()</h3><p>this.setState()，该方法接收两种参数：对象或函数。</p>\n<pre><code class=\"js\">this.setState(partialState, [callback]);\n</code></pre>\n<ul>\n<li><code>partialState</code>: 需要更新的状态的部分对象</li>\n<li><code>callback</code>: 更新完状态后的回调函数</li>\n</ul>\n<p><strong>有两种写法:</strong></p>\n<ol>\n<li><p>对象：即想要修改的 state</p>\n<pre><code class=\"js\">this.setState(&#123;\n    isHot: false,\n&#125;);\n</code></pre>\n</li>\n<li><p>函数：接收两个函数，第一个函数接受两个参数，第一个是当前 state，第二个是当前 props，该函数返回一个对象，和直接传递对象参数是一样的，就是要修改的 state；第二个函数参数是 state 改变后触发的回调</p>\n</li>\n</ol>\n<pre><code class=\"js\">this.setState(state =&gt; (&#123;count: state.count+1&#125;);\n</code></pre>\n<ul>\n<li>在执行 <code>setState</code>操作后，React 会自动调用一次 <code>render()</code></li>\n<li><code>render()</code> 的执行次数是 1+n (1 为初始化时的自动调用，n 为状态更新的次数)</li>\n</ul>\n<h3 id=\"2-3-简化版本\"><a href=\"#2-3-简化版本\" class=\"headerlink\" title=\"2.3 简化版本\"></a>2.3 简化版本</h3><ol>\n<li><p>state 的赋值可以不再构造函数中进行</p>\n</li>\n<li><p>使用了箭头函数，将 this 进行了改变</p>\n</li>\n</ol>\n<pre><code class=\"js\">&lt;body&gt;\n    &lt;!-- 准备好容器 --&gt;\n    &lt;div id=&quot;test&quot;&gt;\n\n    &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;script type=&quot;text/babel&quot;&gt;\n        class St extends React.Component&#123;\n            //可以直接对其进行赋值\n            state = &#123;isHot:true&#125;;\n            render()&#123; //这个This也是实例对象\n                return &lt;h1 onClick = &#123;this.dem&#125;&gt;今天天气很&#123;this.state.isHot?&quot;炎热&quot;:&quot;凉爽&quot;&#125;&lt;/h1&gt;\n                //或者使用&#123;()=&gt;this.dem()也是可以的&#125;\n            &#125;\n            //箭头函数 [自定义方法---&gt;要用赋值语句的形式+箭头函数]\n            dem = () =&gt;&#123;\n                console.log(this);\n                const state =  this.state.isHot;\n                this.setState(&#123;isHot:!state&#125;);\n            &#125;\n        &#125;\n        ReactDOM.render(&lt;St /&gt;,document.getElementById(&quot;test&quot;));\n&lt;/script&gt;\n</code></pre>\n<p>如果想要在调用方法的时候传递参数，有两个方法：</p>\n<pre><code class=\"js\">&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;\n&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;\n</code></pre>\n<p>上述两种方式是等价的，分别通过<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭头函数</a>和 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind\"><code>Function.prototype.bind</code></a> 来实现。</p>\n<p>在这两种情况下，React 的事件对象 <code>e</code> 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>\n<h3 id=\"2-4-State-的更新可能是异步的\"><a href=\"#2-4-State-的更新可能是异步的\" class=\"headerlink\" title=\"2.4 State 的更新可能是异步的\"></a>2.4 State 的更新可能是异步的</h3><p><strong>React 控制之外的事件中调用 setState 是同步更新的。比如原生 js 绑定的事件，setTimeout&#x2F;setInterval 等</strong>。</p>\n<blockquote>\n<p>18 版本中测试 setTimeout 回调函数中也是异步更新的</p>\n</blockquote>\n<p><strong>大部分开发中用到的都是 React 封装的事件，比如 onChange、onClick、onTouchMove 等，这些事件处理程序中的 setState 都是异步处理的。</strong></p>\n<pre><code class=\"js\">//1.创建组件\nclass St extends React.Component &#123;\n    //可以直接对其进行赋值\n    state = &#123; isHot: 10 &#125;;\n    render() &#123;\n        //这个This也是实例对象\n        return &lt;h1 onClick=&#123;this.dem&#125;&gt;点击事件&lt;/h1&gt;;\n    &#125;\n    //箭头函数 [自定义方法---&gt;要用赋值语句的形式+箭头函数]\n    dem = () =&gt; &#123;\n        //修改isHot\n        this.setState(&#123; isHot: this.state.isHot + 1 &#125;);\n        console.log(this.state.isHot);\n    &#125;;\n&#125;\n</code></pre>\n<p>上面的案例中预期 setState 使得 isHot 变成了 11，输出也应该是 11。然而在控制台打印的却是 10，也就是并没有对其进行更新。这是因为异步的进行了处理，在输出的时候还没有对其进行处理。</p>\n<pre><code class=\"js\">document.getElementById(&quot;test&quot;).addEventListener(&quot;click&quot;,()=&gt;&#123;\n        this.setState(&#123;isHot: this.state.isHot + 1&#125;);\n        console.log(this.state.isHot);\n    &#125;)\n&#125;\n</code></pre>\n<p>但是通过这个原生 JS 的，可以发现，控制台打印的就是 11，也就是已经对其进行了处理。也就是进行了同步的更新。</p>\n<p><strong>React 怎么调用同步或者异步的呢？</strong></p>\n<p>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中延时更新，而 isBatchingUpdates 默认是 false，表示 setState 会同步更新 this.state；但是，有一个函数 batchedUpdates，该函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会先调用这个 batchedUpdates 将 isBatchingUpdates 修改为 true，这样由 React 控制的事件处理过程 setState 不会同步更新 this.state。</p>\n<p><strong>如果是同步更新，每一个 setState 对调用一个 render，并且如果多次调用 setState 会以最后调用的为准，前面的将会作废；如果是异步更新，多个 setSate 会统一调用一次 render</strong></p>\n<pre><code class=\"js\">dem = () =&gt; &#123;\n    this.setState(&#123;\n        isHot: 1,\n        cont: 444,\n    &#125;);\n    this.setState(&#123;\n        isHot: this.state.isHot + 1,\n    &#125;);\n    this.setState(&#123;\n        isHot: 888,\n        cont: 888,\n    &#125;);\n&#125;;\n</code></pre>\n<p>上面的最后会输出：isHot 是 888，cont 是 888</p>\n<pre><code class=\"js\">dem = () =&gt; &#123;\n    this.setState(&#123;\n        isHot: this.state.isHot + 1,\n    &#125;);\n    this.setState(&#123;\n        isHot: this.state.isHot + 1,\n    &#125;);\n    this.setState(&#123;\n        isHot: this.state.isHot + 888,\n    &#125;);\n&#125;;\n</code></pre>\n<p>初始 isHot 为 10，最后 isHot 输出为 898，也就是前面两个都没有执行。</p>\n<p>**注意！！这是异步更新才有的，如果同步更新，每一次都会调用 render，这样每一次更新都会 **</p>\n<h3 id=\"2-5-异步更新解决方案\"><a href=\"#2-5-异步更新解决方案\" class=\"headerlink\" title=\"2.5 异步更新解决方案\"></a>2.5 异步更新解决方案</h3><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用。</p>\n<p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p>\n<p>例如，此代码可能会无法更新计数器：</p>\n<pre><code class=\"js\">// Wrong\nthis.setState(&#123;\n    counter: this.state.counter + this.props.increment,\n&#125;);\n</code></pre>\n<p>要解决这个问题，可以让 <code>setState()</code> 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p>\n<pre><code class=\"js\">// Correct\nthis.setState((state, props) =&gt; (&#123;\n    counter: state.counter + props.increment,\n&#125;));\n</code></pre>\n<p>上面使用了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭头函数</a>，不过使用普通的函数也同样可以：</p>\n<pre><code class=\"js\">// Correct\nthis.setState(function (state, props) &#123;\n    return &#123;\n        counter: state.counter + props.increment,\n    &#125;;\n&#125;);\n</code></pre>\n<h3 id=\"2-6-数据是向下流动的\"><a href=\"#2-6-数据是向下流动的\" class=\"headerlink\" title=\"2.6 数据是向下流动的\"></a>2.6 数据是向下流动的</h3><p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p>\n<p>这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p>\n<p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中：</p>\n<pre><code class=\"js\">&lt;FormattedDate date=&#123;this.state.date&#125; /&gt;\n</code></pre>\n<p><code>FormattedDate</code> 组件会在其 props 中接收参数 <code>date</code>，但是组件本身无法知道它是来自于 <code>Clock</code> 的 state，或是 <code>Clock</code> 的 props，还是手动输入的：</p>\n<pre><code class=\"js\">function FormattedDate(props) &#123;\n    return &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;\n&#125;\n</code></pre>\n<p><a href=\"https://codepen.io/gaearon/pen/zKRqNB?editors=0010\"><strong>在 CodePen 上尝试</strong></a></p>\n<p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p>\n<p>如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p>\n<p>为了证明每个组件都是真正独立的，我们可以创建一个渲染三个 <code>Clock</code> 的 <code>App</code> 组件：</p>\n<pre><code class=\"js\">function App() &#123;\n    return (\n        &lt;div&gt;\n            &lt;Clock /&gt;\n            &lt;Clock /&gt;\n            &lt;Clock /&gt;\n        &lt;/div&gt;\n    );\n&#125;\n</code></pre>\n<p><a href=\"https://codepen.io/gaearon/pen/vXdGmd?editors=0010\"><strong>在 CodePen 上尝试</strong></a></p>\n<p>每个 <code>Clock</code> 组件都会单独设置它自己的计时器并且更新它。</p>\n<p>在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然。</p>\n<h2 id=\"3-props\"><a href=\"#3-props\" class=\"headerlink\" title=\"3.props\"></a>3.props</h2><h3 id=\"3-1-基本使用\"><a href=\"#3-1-基本使用\" class=\"headerlink\" title=\"3.1 基本使用\"></a>3.1 基本使用</h3><p>与<code>state</code>不同，<code>state</code>是组件自身的状态，而<code>props</code>则是外部传入的数据</p>\n<p>基本使用：</p>\n<pre><code class=\"js\">&lt;body&gt;\n    &lt;div id = &quot;div&quot;&gt;\n\n    &lt;/div&gt;\n\n&lt;/body&gt;\n&lt;script type=&quot;text/babel&quot;&gt;\n    class Person extends React.Component&#123;\n        render()&#123;\n          const &#123; name, age, sex &#125; = this.props\n            return (\n                &lt;ul&gt;\n                  &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;\n                  &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;\n                  &lt;li&gt;年龄：&#123;age + 1&#125;&lt;/li&gt;\n                &lt;/ul&gt;\n          )\n        &#125;\n    &#125;\n    //传递数据\n    ReactDOM.render(&lt;Person name=&quot;tom&quot; age = &#123;41&#125; sex=&quot;男&quot;/&gt;,document.getElementById(&quot;div&quot;));\n&lt;/script&gt;\n</code></pre>\n<p>如果传递的数据是一个对象，可以更加简便的使用</p>\n<pre><code class=\"js\">&lt;script type=&quot;text/babel&quot;&gt;\n    class Person extends React.Component&#123;\n        render()&#123;\n            return (\n                &lt;ul&gt;\n                    &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;\n                    &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;\n                    &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;\n                &lt;/ul&gt;\n            )\n        &#125;\n    &#125;\n    const p = &#123;name:&quot;张三&quot;,age:&quot;18&quot;,sex:&quot;女&quot;&#125;\n   ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&quot;div&quot;));\n&lt;/script&gt;\n</code></pre>\n<p>… 这个符号恐怕都不陌生，这个是一个展开运算符，主要用来展开数组，如下面这个例子：</p>\n<pre><code class=\"js\">arr = [1, 2, 3];\narr1 = [4, 5, 6];\narr2 = [...arr, ...arr1]; //arr2 = [1,2,3,4,5,6]\n</code></pre>\n<p>但是他还有其他的用法：</p>\n<p>1.复制一个对象给另一个对象{…对象名}。此时这两个对象并没有什么联系了</p>\n<pre><code class=\"js\">const p1 = &#123; name: &quot;张三&quot;, age: &quot;18&quot;, sex: &quot;女&quot; &#125;;\nconst p2 = &#123; ...p1 &#125;;\np1.name = &quot;sss&quot;;\nconsole.log(p2); //&#123;name:&quot;张三&quot;,age:&quot;18&quot;,sex:&quot;女&quot;&#125;\n</code></pre>\n<p>2.在复制的时候，合并其中的属性</p>\n<pre><code class=\"js\">const p1 = &#123; name: &quot;张三&quot;, age: &quot;18&quot;, sex: &quot;女&quot; &#125;;\nconst p2 = &#123; ...p1, name: &quot;111&quot;, hua: &quot;ss&quot; &#125;;\np1.name = &quot;sss&quot;;\nconsole.log(p2); //&#123;name: &quot;111&quot;, age: &quot;18&quot;, sex: &quot;女&quot;,hua:&quot;ss&quot;&#125;\n</code></pre>\n<p><strong>注意！！</strong> <strong>{…P}并不能展开一个对象</strong></p>\n<p><strong>props 传递一个对象，是因为 babel+react 使得{..p}可以展开对象，但是只有在标签中才能使用</strong></p>\n<h3 id=\"3-2-props-限制\"><a href=\"#3-2-props-限制\" class=\"headerlink\" title=\"3.2 props 限制\"></a>3.2 props 限制</h3><blockquote>\n<p>注意：</p>\n<p>自 React v15.5 起，<code>React.PropTypes</code> 已移入另一个包中。请使用 <a href=\"https://www.npmjs.com/package/prop-types\"><code>prop-types</code> 库</a> 代替。</p>\n<p>我们提供了一个 <a href=\"https://zh-hans.reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-reactproptypes\">codemod 脚本</a>来做自动转换。</p>\n</blockquote>\n<p>随着你的应用程序不断增长，你可以通过类型检查捕获大量错误。对于某些应用程序来说，你可以使用 <a href=\"https://flow.org/\">Flow</a> 或 <a href=\"https://www.typescriptlang.org/\">TypeScript</a> 等 JavaScript 扩展来对整个应用程序做类型检查。但即使你不使用这些扩展，React 也内置了一些类型检查的功能。要在组件的 props 上进行类型检查，你只需配置特定的 <code>propTypes</code> 属性：</p>\n<p>react 对此提供了相应的解决方法：</p>\n<ul>\n<li>propTypes:类型检查，还可以限制不能为空</li>\n<li>defaultProps：默认值</li>\n</ul>\n<blockquote>\n<p>从 ES2022 开始，你也可以在 React 类组件中将 <code>defaultProps</code> 声明为静态属性。欲了解更多信息，请参阅 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields#public_static_fields\">class public static fields</a>。这种现代语法需要添加额外的编译步骤才能在老版浏览器中工作。</p>\n</blockquote>\n<pre><code class=\"js\">&lt;!-- 准备好一个“容器” --&gt;\n&lt;div id=&quot;test1&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;test2&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;test3&quot;&gt;&lt;/div&gt;\n\n&lt;script type=&quot;text/babel&quot;&gt;\n    //创建组件\n    class Person extends React.Component&#123;\n        render()&#123;\n            // console.log(this);\n            const &#123;name,age,sex&#125; = this.props\n            //props是只读的\n            //this.props.name = &#39;jack&#39; //此行代码会报错，因为props是只读的\n            return (\n                &lt;ul&gt;\n                    &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;\n                    &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;\n                    &lt;li&gt;年龄：&#123;age+1&#125;&lt;/li&gt;\n                &lt;/ul&gt;\n            )\n        &#125;\n    &#125;\n    //对标签属性进行类型、必要性的限制\n    Person.propTypes = &#123;\n        name:PropTypes.string.isRequired, //限制name必传，且为字符串\n        sex:PropTypes.string,//限制sex为字符串\n        age:PropTypes.number,//限制age为数值\n        speak:PropTypes.func,//限制speak为函数\n    &#125;\n    //指定默认标签属性值\n    Person.defaultProps = &#123;\n        sex:&#39;男&#39;,//sex默认值为男\n        age:18 //age默认值为18\n    &#125;\n    //渲染组件到页面\n    ReactDOM.render(&lt;Person name=&#123;100&#125; speak=&#123;speak&#125;/&gt;,document.getElementById(&#39;test1&#39;))\n    ReactDOM.render(&lt;Person name=&quot;tom&quot; age=&#123;18&#125; sex=&quot;女&quot;/&gt;,document.getElementById(&#39;test2&#39;))\n\n    const p = &#123;name:&#39;老刘&#39;,age:18,sex:&#39;女&#39;&#125;\n    // console.log(&#39;@&#39;,...p);\n    // ReactDOM.render(&lt;Person name=&#123;p.name&#125; age=&#123;p.age&#125; sex=&#123;p.sex&#125;/&gt;,document.getElementById(&#39;test3&#39;))\n    ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test3&#39;))\n\n    function speak()&#123;\n        console.log(&#39;我说话了&#39;);\n    &#125;\n&lt;/script&gt;\n</code></pre>\n<p>当传入的 <code>prop</code> 值类型不正确时，JavaScript 控制台将会显示警告。出于性能方面的考虑，<code>propTypes</code> 仅在开发模式下进行检查。</p>\n<p><code>defaultProps</code> 用于确保 <code>this.props.sex</code> 在父组件没有指定其值时，有一个默认值。<code>propTypes</code> 类型检查发生在 <code>defaultProps</code> 赋值后，所以类型检查也适用于 <code>defaultProps</code>。</p>\n<p><strong>PropTypes</strong></p>\n<p>以下提供了使用不同验证器的例子：</p>\n<pre><code class=\"js\">import PropTypes from &quot;prop-types&quot;;\n\nMyComponent.propTypes = &#123;\n    // 你可以将属性声明为 JS 原生类型，默认情况下\n    // 这些属性都是可选的。\n    optionalArray: PropTypes.array,\n    optionalBool: PropTypes.bool,\n    optionalFunc: PropTypes.func,\n    optionalNumber: PropTypes.number,\n    optionalObject: PropTypes.object,\n    optionalString: PropTypes.string,\n    optionalSymbol: PropTypes.symbol,\n\n    // 任何可被渲染的元素（包括数字、字符串、元素或数组）\n    // (或 Fragment) 也包含这些类型。\n    optionalNode: PropTypes.node,\n\n    // 一个 React 元素。\n    optionalElement: PropTypes.element,\n\n    // 一个 React 元素类型（即，MyComponent）。\n    optionalElementType: PropTypes.elementType,\n\n    // 你也可以声明 prop 为类的实例，这里使用\n    // JS 的 instanceof 操作符。\n    optionalMessage: PropTypes.instanceOf(Message),\n\n    // 你可以让你的 prop 只能是特定的值，指定它为\n    // 枚举类型。\n    optionalEnum: PropTypes.oneOf([&quot;News&quot;, &quot;Photos&quot;]),\n\n    // 一个对象可以是几种类型中的任意一个类型\n    optionalUnion: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message)]),\n\n    // 可以指定一个数组由某一类型的元素组成\n    optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n    // 可以指定一个对象由某一类型的值组成\n    optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n    // 可以指定一个对象由特定的类型值组成\n    optionalObjectWithShape: PropTypes.shape(&#123;\n        color: PropTypes.string,\n        fontSize: PropTypes.number,\n    &#125;),\n\n    // 具有额外属性警告的对象\n    optionalObjectWithStrictShape: PropTypes.exact(&#123;\n        name: PropTypes.string,\n        quantity: PropTypes.number,\n    &#125;),\n\n    // 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保\n    // 这个 prop 没有被提供时，会打印警告信息。\n    requiredFunc: PropTypes.func.isRequired,\n\n    // 任意类型的必需数据\n    requiredAny: PropTypes.any.isRequired,\n\n    // 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。\n    // 请不要使用 `console.warn` 或抛出异常，因为这在 `oneOfType` 中不会起作用。\n    customProp: function (props, propName, componentName) &#123;\n        if (!/matchme/.test(props[propName])) &#123;\n            return new Error(&quot;Invalid prop `&quot; + propName + &quot;` supplied to&quot; + &quot; `&quot; + componentName + &quot;`. Validation failed.&quot;);\n        &#125;\n    &#125;,\n\n    // 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。\n    // 它应该在验证失败时返回一个 Error 对象。\n    // 验证器将验证数组或对象中的每个值。验证器的前两个参数\n    // 第一个是数组或对象本身\n    // 第二个是他们当前的键。\n    customArrayProp: PropTypes.arrayOf(function (propValue, key, componentName, location, propFullName) &#123;\n        if (!/matchme/.test(propValue[key])) &#123;\n            return new Error(&quot;Invalid prop `&quot; + propFullName + &quot;` supplied to&quot; + &quot; `&quot; + componentName + &quot;`. Validation failed.&quot;);\n        &#125;\n    &#125;),\n&#125;;\n</code></pre>\n<p><strong>限制单个元素</strong></p>\n<p>你可以通过 <code>PropTypes.element</code> 来确保传递给组件的 children 中只包含一个元素。</p>\n<pre><code class=\"js\">import PropTypes from &quot;prop-types&quot;;\n\nclass MyComponent extends React.Component &#123;\n    render() &#123;\n        // 这必须只有一个元素，否则控制台会打印警告。\n        const children = this.props.children;\n        return &lt;div&gt;&#123;children&#125;&lt;/div&gt;;\n    &#125;\n&#125;\n\nMyComponent.propTypes = &#123;\n    children: PropTypes.element.isRequired,\n&#125;;\n</code></pre>\n<h3 id=\"3-3-简写方式\"><a href=\"#3-3-简写方式\" class=\"headerlink\" title=\"3.3 简写方式\"></a>3.3 简写方式</h3><pre><code class=\"js\">&lt;!-- 准备好一个“容器” --&gt;\n&lt;div id=&quot;test1&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;test2&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;test3&quot;&gt;&lt;/div&gt;\n\n\n&lt;script type=&quot;text/babel&quot;&gt;\n    //创建组件\n    class Person extends React.Component&#123;\n\n        constructor(props)&#123;\n            //构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props\n            // console.log(props);\n            super(props)\n            console.log(&#39;constructor&#39;,this.props);\n        &#125;\n\n        //对标签属性进行类型、必要性的限制\n        static propTypes = &#123;\n            name:PropTypes.string.isRequired, //限制name必传，且为字符串\n            sex:PropTypes.string,//限制sex为字符串\n            age:PropTypes.number,//限制age为数值\n        &#125;\n\n        //指定默认标签属性值\n        static defaultProps = &#123;\n            sex:&#39;男&#39;,//sex默认值为男\n            age:18 //age默认值为18\n        &#125;\n\n        render()&#123;\n            // console.log(this);\n            const &#123;name,age,sex&#125; = this.props\n            //props是只读的\n            //this.props.name = &#39;jack&#39; //此行代码会报错，因为props是只读的\n            return (\n                &lt;ul&gt;\n                    &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;\n                    &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;\n                    &lt;li&gt;年龄：&#123;age+1&#125;&lt;/li&gt;\n                &lt;/ul&gt;\n            )\n        &#125;\n    &#125;\n\n    //渲染组件到页面\n    ReactDOM.render(&lt;Person name=&quot;jerry&quot;/&gt;,document.getElementById(&#39;test1&#39;))\n&lt;/script&gt;\n</code></pre>\n<p>在使用的时候可以通过 <code>this.props</code>来获取值 类式组件的 <code>props</code>:</p>\n<ol>\n<li>通过在组件标签上传递值，在组件中就可以获取到所传递的值</li>\n<li>在构造器里的<code>props</code>参数里可以获取到 <code>props</code></li>\n<li>可以分别设置 <code>propTypes</code> 和 <code>defaultProps</code> 两个属性来分别操作 <code>props</code>的规范和默认值，两者都是直接添加在类式组件的<strong>原型对象</strong>上的（所以需要添加 <code>static</code>）</li>\n<li>同时可以通过<code>...</code>运算符来简化</li>\n</ol>\n<h3 id=\"3-4-函数式组件的使用\"><a href=\"#3-4-函数式组件的使用\" class=\"headerlink\" title=\"3.4 函数式组件的使用\"></a>3.4 函数式组件的使用</h3><blockquote>\n<p>函数在使用 props 的时候，是作为参数进行使用的(props)</p>\n</blockquote>\n<pre><code class=\"js\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;title&gt;对props进行限制&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 准备好一个“容器” --&gt;\n    &lt;div id=&quot;test1&quot;&gt;&lt;/div&gt;\n\n    &lt;script type=&quot;text/babel&quot;&gt;\n      //创建组件\n      function Person(props) &#123;\n        const &#123; name, age, sex &#125; = props\n        return (\n          &lt;ul&gt;\n            &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;\n            &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;\n            &lt;li&gt;年龄：&#123;age&#125;&lt;/li&gt;\n          &lt;/ul&gt;\n        )\n      &#125;\n      Person.propTypes = &#123;\n        name: PropTypes.string.isRequired, //限制name必传，且为字符串\n        sex: PropTypes.string, //限制sex为字符串\n        age: PropTypes.number, //限制age为数值\n      &#125;\n\n      //指定默认标签属性值\n      Person.defaultProps = &#123;\n        sex: &#39;男&#39;, //sex默认值为男\n        age: 18, //age默认值为18\n      &#125;\n      //渲染组件到页面\n      ReactDOM.render(&lt;Person name=&quot;jerry&quot; /&gt;, document.getElementById(&#39;test1&#39;))\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>函数组件的 <code>props</code>定义:</p>\n<ol>\n<li>在组件标签中传递 <code>props</code>的值</li>\n<li>组件函数的参数为 <code>props</code></li>\n<li>对 <code>props</code>的限制和默认值同样设置在原型对象上</li>\n</ol>\n<h3 id=\"3-5-props-的只读性\"><a href=\"#3-5-props-的只读性\" class=\"headerlink\" title=\"3.5 props 的只读性\"></a>3.5 props 的只读性</h3><p>组件无论是使用<a href=\"https://zh-hans.reactjs.org/docs/components-and-props.html#function-and-class-components\">函数声明还是通过 class 声明</a>，都绝不能修改自身的 props。来看下这个 <code>sum</code> 函数：</p>\n<pre><code class=\"js\">function sum(a, b) &#123;\n    return a + b;\n&#125;\n</code></pre>\n<p>这样的函数被称为<a href=\"https://en.wikipedia.org/wiki/Pure_function\">“纯函数”</a>，因为该函数不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果。</p>\n<p>相反，下面这个函数则不是纯函数，因为它更改了自己的入参：</p>\n<pre><code class=\"js\">function withdraw(account, amount) &#123;\n    account.total -= amount;\n&#125;\n</code></pre>\n<p>React 非常灵活，但它也有一个严格的规则：</p>\n<p><strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong></p>\n<p>当然，应用程序的 UI 是动态的，并会伴随着时间的推移而变化。<code>state</code>在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。</p>\n<h2 id=\"4-refs\"><a href=\"#4-refs\" class=\"headerlink\" title=\"4.refs\"></a>4.refs</h2><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 <code>render</code> 方法中创建的 React 元素。</p>\n<p>在典型的 React 数据流中，<a href=\"https://zh-hans.reactjs.org/docs/components-and-props.html\">props</a> 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。但是，在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。对于这两种情况，React 都提供了解决办法。</p>\n<blockquote>\n<p>在我们正常的操作节点时，需要采用 DOM API 来查找元素，但是这样违背了 React 的理念，因此有了<code>refs</code></p>\n</blockquote>\n<p><strong>何时使用 Refs</strong></p>\n<p>下面是几个适合使用 refs 的情况：</p>\n<ul>\n<li>管理焦点，文本选择或媒体播放。</li>\n<li>触发强制动画。</li>\n<li>集成第三方 DOM 库。</li>\n</ul>\n<p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。</p>\n<p><strong>有三种操作<code>refs</code>的方法，分别为：</strong></p>\n<ul>\n<li>字符串形式</li>\n<li>回调形式</li>\n<li><code>createRef</code>形式</li>\n</ul>\n<p><strong>勿过度使用 Refs</strong></p>\n<p>你可能首先会想到使用 refs 在你的 app 中“让事情发生”。如果是这种情况，请花一点时间，认真再考虑一下 state 属性应该被安排在哪个组件层中。通常你会想明白，让更高的组件层级拥有这个 state，是更恰当的。查看 <a href=\"https://zh-hans.reactjs.org/docs/lifting-state-up.html\">状态提升</a> 以获取更多有关示例。</p>\n<h3 id=\"4-1-字符串形式\"><a href=\"#4-1-字符串形式\" class=\"headerlink\" title=\"4.1 字符串形式\"></a>4.1 字符串形式</h3><p>在想要获取到一个 DOM 节点，可以直接在这个节点上添加 ref 属性。利用该属性进行获取该节点的值。</p>\n<p>案例：给需要的节点添加 ref 属性，此时该实例对象的 refs 上就会有这个值。就可以利用实例对象的 refs 获取已经添加节点的值</p>\n<pre><code class=\"js\">&lt;input ref=&quot;dian&quot; type=&quot;text&quot; placeholder=&quot;点击弹出&quot; /&gt;;\n\ninputBlur = () =&gt; &#123;\n    alert(this.refs.shiqu.value);\n&#125;;\n</code></pre>\n<p><strong>注意</strong></p>\n<p>不建议使用它，因为 string 类型的 refs 存在 <a href=\"https://github.com/facebook/react/pull/8333#issuecomment-271648615\">一些问题</a>。它已过时并可能会在未来的版本被移除。</p>\n<p>如果你目前还在使用 <code>this.refs.textInput</code> 这种方式访问 refs ，我们建议用<a href=\"https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#callback-refs\">回调函数</a>或 <a href=\"https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#creating-refs\"><code>createRef</code> API</a> 的方式代替。</p>\n<h3 id=\"4-2-回调形式\"><a href=\"#4-2-回调形式\" class=\"headerlink\" title=\"4.2 回调形式\"></a>4.2 回调形式</h3><p>React 也支持另一种设置 refs 的方式，称为“回调 refs”。它能助你更精细地控制何时 refs 被设置和解除。</p>\n<p>这种方式会将该 DOM 作为参数传递过去。</p>\n<p>组件实例的<code>ref</code>属性传递一个回调函数<code>c =&gt; this.input1 = c </code>（箭头函数简写），这样会在实例的属性中存储对 DOM 节点的引用，使用时可通过<code>this.input1</code>来使用</p>\n<pre><code class=\"js\">&lt;input ref=&#123;(e) =&gt; (this.input1 = e)&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot; /&gt;\n</code></pre>\n<p><code>e</code>会接收到当前节点作为参数，然后将当前节点赋值给实例的<code>input1</code>属性上面</p>\n<p><strong>关于回调 refs 的说明</strong></p>\n<p>如果 <code>ref</code> 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 <code>null</code>，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p>\n<pre><code class=\"js\">class Demo extends React.Component &#123;\n    state = &#123; isHot: false &#125;;\n\n    changeWeather = () =&gt; &#123;\n        //获取原来的状态\n        const &#123; isHot &#125; = this.state;\n        //更新状态\n        this.setState(&#123; isHot: !isHot &#125;);\n    &#125;;\n\n    render() &#123;\n        const &#123; isHot &#125; = this.state;\n        return (\n            &lt;div&gt;\n                &lt;h2&gt;今天天气很&#123;isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;&lt;/h2&gt;\n                &lt;input\n                    ref=&#123;(c) =&gt; &#123;\n                        this.input1 = c;\n                        console.log(&quot;@&quot;, c);\n                    &#125;&#125;\n                    type=&quot;text&quot;\n                /&gt;\n                &lt;br /&gt;\n                &lt;br /&gt;\n                &lt;button onClick=&#123;this.changeWeather&#125;&gt;点我切换天气&lt;/button&gt;\n            &lt;/div&gt;\n        );\n    &#125;\n&#125;\n</code></pre>\n<p>刚渲染完会调用一次</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/40ec77c4a5ab8d3ca9bcb67eb2f1a2e80bc8d2ed.png\" alt=\"image-20221023153439400\"></p>\n<p>触发模板更新会调用两次</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/6caaacc85071b8b9ed0040e1969be621b4795a61.png\" alt=\"image-20221023153510564\"></p>\n<p>第一次传递一个 null 值把之前的属性清空，再重新赋值。</p>\n<p>如果不想总是这样重新创建新的函数，可以使用下面的方案</p>\n<p>下面的例子描述了一个通用的范例：使用 <code>ref</code> 回调函数，在实例的属性中存储对 DOM 节点的引用。</p>\n<pre><code class=\"js\">//创建组件\nclass Demo extends React.Component &#123;\n    state = &#123; isHot: false &#125;;\n    // 在实例上面创建一个函数\n    setTextInputRef = (e) =&gt; &#123;\n        this.input1 = e;\n    &#125;;\n\n    changeWeather = () =&gt; &#123;\n        console.log(this.input1);\n        //获取原来的状态\n        const &#123; isHot &#125; = this.state;\n        //更新状态\n        this.setState(&#123; isHot: !isHot &#125;);\n    &#125;;\n\n    render() &#123;\n        const &#123; isHot &#125; = this.state;\n        return (\n            &lt;div&gt;\n                &lt;h2&gt;今天天气很&#123;isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;&lt;/h2&gt;\n                &lt;input ref=&#123;this.setTextInputRef&#125; type=&quot;text&quot; /&gt;\n                &lt;br /&gt;\n                &lt;button onClick=&#123;this.changeWeather&#125;&gt;点我切换天气&lt;/button&gt;\n            &lt;/div&gt;\n        );\n    &#125;\n&#125;\n</code></pre>\n<p>React 将在组件挂载时，会调用 <code>ref</code> 回调函数并传入 DOM 元素，当卸载时调用它并传入 <code>null</code>。</p>\n<p>你可以在组件间传递回调形式的 refs，就像你可以传递通过 <code>React.createRef()</code> 创建的对象 refs 一样。</p>\n<pre><code class=\"js\">function CustomTextInput(props) &#123;\n    return (\n        &lt;div&gt;\n            &lt;input ref=&#123;props.inputRef&#125; /&gt;\n        &lt;/div&gt;\n    );\n&#125;\n\nclass Parent extends React.Component &#123;\n    render() &#123;\n        return &lt;CustomTextInput inputRef=&#123;(el) =&gt; (this.inputElement = el)&#125; /&gt;;\n    &#125;\n&#125;\n</code></pre>\n<p>在上面的例子中，<code>Parent</code> 把它的 refs 回调函数当作 <code>inputRef</code> props 传递给了 <code>CustomTextInput</code>，而且 <code>CustomTextInput</code> 把相同的函数作为特殊的 <code>ref</code> 属性传递给了 <code>&lt;input&gt;</code>。结果是，在 <code>Parent</code> 中的 <code>this.inputElement</code> 会被设置为与 <code>CustomTextInput</code> 中的 <code>input</code> 元素相对应的 DOM 节点。</p>\n<h3 id=\"4-3-createRef-形式（推荐写法）\"><a href=\"#4-3-createRef-形式（推荐写法）\" class=\"headerlink\" title=\"4.3 createRef 形式（推荐写法）\"></a>4.3 createRef 形式（推荐写法）</h3><p><strong>创建 Refs</strong></p>\n<p>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。</p>\n<pre><code class=\"js\">class MyComponent extends React.Component &#123;\n    constructor(props) &#123;\n        super(props);\n        this.myRef = React.createRef();\n    &#125;\n    render() &#123;\n        return &lt;div ref=&#123;this.myRef&#125; /&gt;;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>访问 Refs</strong></p>\n<p>当 ref 被传递给 <code>render</code> 中的元素时，对该节点的引用可以在 ref 的 <code>current</code> 属性中被访问。</p>\n<pre><code class=\"js\">const node = this.myRef.current;\n</code></pre>\n<p>ref 的值根据节点的类型而有所不同：</p>\n<ul>\n<li>当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。</li>\n<li>当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</li>\n<li><strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为他们没有实例。</li>\n</ul>\n<h3 id=\"4-4-为-DOM-元素添加-ref\"><a href=\"#4-4-为-DOM-元素添加-ref\" class=\"headerlink\" title=\"4.4 为 DOM 元素添加 ref\"></a>4.4 为 DOM 元素添加 ref</h3><p>以下代码使用 <code>ref</code> 去存储 DOM 节点的引用：</p>\n<pre><code class=\"js\">class CustomTextInput extends React.Component &#123;\n    constructor(props) &#123;\n        super(props);\n        // 创建一个 ref 来存储 textInput 的 DOM 元素\n        this.textInput = React.createRef();\n        this.focusTextInput = this.focusTextInput.bind(this);\n    &#125;\n\n    focusTextInput() &#123;\n        // 直接使用原生 API 使 text 输入框获得焦点\n        // 注意：我们通过 &quot;current&quot; 来访问 DOM 节点\n        this.textInput.current.focus();\n    &#125;\n\n    render() &#123;\n        // 告诉 React 我们想把 &lt;input&gt; ref 关联到\n        // 构造器里创建的 `textInput` 上\n        return (\n            &lt;div&gt;\n                &lt;input type=&quot;text&quot; ref=&#123;this.textInput&#125; /&gt;\n                &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.focusTextInput&#125; /&gt;\n            &lt;/div&gt;\n        );\n    &#125;\n&#125;\n</code></pre>\n<p>React 会在组件挂载时给 <code>current</code> 属性传入 DOM 元素，并在组件卸载时传入 <code>null</code> 值。<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</p>\n<p>注意：我们不要过度的使用 ref，如果发生时间的元素刚好是需要操作的元素，就可以使用事件对象去替代。</p>\n<h3 id=\"4-5-为-class-组件添加-Ref\"><a href=\"#4-5-为-class-组件添加-Ref\" class=\"headerlink\" title=\"4.5 为 class 组件添加 Ref\"></a>4.5 为 class 组件添加 Ref</h3><p>如果我们想包装上面的 <code>CustomTextInput</code>，来模拟它挂载之后立即被点击的操作，我们可以使用 ref 来获取这个自定义的 input 组件并手动调用它的 <code>focusTextInput</code> 方法：</p>\n<pre><code class=\"js\">class AutoFocusTextInput extends React.Component &#123;\n    constructor(props) &#123;\n        super(props);\n        this.textInput = React.createRef();\n    &#125;\n\n    componentDidMount() &#123;\n        this.textInput.current.focusTextInput();\n    &#125;\n\n    render() &#123;\n        return &lt;CustomTextInput ref=&#123;this.textInput&#125; /&gt;;\n    &#125;\n&#125;\n</code></pre>\n<p>请注意，这仅在 <code>CustomTextInput</code> 声明为 class 时才有效：</p>\n<pre><code class=\"js\">class CustomTextInput extends React.Component &#123;\n    // ...\n&#125;\n</code></pre>\n<h3 id=\"4-6-Refs-与函数组件\"><a href=\"#4-6-Refs-与函数组件\" class=\"headerlink\" title=\"4.6 Refs 与函数组件\"></a>4.6 Refs 与函数组件</h3><p>默认情况下，<strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为它们没有实例：</p>\n<pre><code class=\"js\">function MyFunctionComponent() &#123;\n    return &lt;input /&gt;;\n&#125;\n\nclass Parent extends React.Component &#123;\n    constructor(props) &#123;\n        super(props);\n        this.textInput = React.createRef();\n    &#125;\n    render() &#123;\n        // This will *not* work!\n        return &lt;MyFunctionComponent ref=&#123;this.textInput&#125; /&gt;;\n    &#125;\n&#125;\n</code></pre>\n<p>如果要在函数组件中使用 <code>ref</code>，你可以使用 <a href=\"https://zh-hans.reactjs.org/docs/forwarding-refs.html\"><code>forwardRef</code></a>（可与 <a href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle\"><code>useImperativeHandle</code></a> 结合使用），或者可以将该组件转化为 class 组件。</p>\n<p>不管怎样，你可以<strong>在函数组件内部使用 <code>ref</code> 属性</strong>，只要它指向一个 DOM 元素或 class 组件：</p>\n<pre><code class=\"js\">function CustomTextInput(props) &#123;\n    // 这里必须声明 textInput，这样 ref 才可以引用它\n    const textInput = useRef(null);\n\n    function handleClick() &#123;\n        textInput.current.focus();\n    &#125;\n\n    return (\n        &lt;div&gt;\n            &lt;input type=&quot;text&quot; ref=&#123;textInput&#125; /&gt;\n            &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;handleClick&#125; /&gt;\n        &lt;/div&gt;\n    );\n&#125;\n</code></pre>\n",
            "tags": [
                "React"
            ]
        }
    ]
}